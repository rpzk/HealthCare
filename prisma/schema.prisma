generator client {
  provider      = "prisma-client-js"
  engineType    = "client"
}

datasource db {
  provider = "postgresql"
}

model User {
  id                     String                 @id @default(cuid())
  email                  String                 @unique
  name                   String
  role                   Role                   @default(DOCTOR)
  speciality             String?
  crmNumber              String?                @unique
  licenseNumber          String? // Generic for CRM, COREN, CRP, etc.
  licenseType            String? // 'CRM', 'COREN', 'CRP', 'OAB', etc.
  licenseState           String? // 'SP', 'RJ', etc.
  phone                  String?
  patientId              String?                @unique
  patient                Patient?               @relation("UserPatient", fields: [patientId], references: [id])
  isActive               Boolean                @default(true)
  createdAt              DateTime               @default(now())
  updatedAt              DateTime               @updatedAt
  password               String?
  aiInteractions         AIInteraction[]
  consultations          Consultation[]
  examRequests           ExamRequest[]
  medicalRecords         MedicalRecord[]
  notifications          Notification[]
  patients               Patient[]
  prescriptions          Prescription[]
  referrals              Referral[]
  scheduleExceptions     ScheduleException[]
  person                 Person?
  termAcceptances        TermAcceptance[]
  dataDeletionRequests   DataDeletionRequest[]
  protocols              Protocol[] // Protocolos criados pelo médico

  // Passkeys / WebAuthn credentials

  // HR Management relations

  // Convites de pacientes enviados

  // Convites onde este usuário foi escolhido como médico responsável

  // Fila de espera (médicos)
  waitingLists WaitingList[]

  // Questionários integrativos
  questionnaireTemplates QuestionnaireTemplate[]
  sentQuestionnaires     PatientQuestionnaire[]  @relation("SentQuestionnaires")

  // Equipe de cuidado
  careTeamMemberships PatientCareTeam[]

  // Combos de exames criados
  examCombos ExamCombo[]

  // Papéis atribuídos (permite que um usuário tenha múltiplos papéis)
  assignedRoles UserAssignedRole[]

  // Telemedicina - Gravações como médico
  doctorRecordings      TelemedicineRecording[] @relation("DoctorRecordings")

  // Atestados médicos emitidos
  medicalCertificates MedicalCertificate[] @relation("DoctorCertificates")

  // NPS recebidos
  npsResponses NpsResponse[] @relation("DoctorNpsResponses")

  // Assinatura Digital
  digitalCertificates DigitalCertificate[] @relation("UserDigitalCertificates")
  signedDocuments     SignedDocument[]     @relation("UserSignedDocuments")

  // ACS (Agente Comunitário de Saúde) Management
  acsAssignedMicroAreaId String?
  acsAssignedMicroArea   MicroArea? @relation("ACSMicroArea", fields: [acsAssignedMicroAreaId], references: [id], onDelete: SetNull)

  assignedAreaId String?
  assignedArea   Area?   @relation("AssignedArea", fields: [assignedAreaId], references: [id], onDelete: SetNull)

  // Referrals as destination doctor
  destinationReferrals Referral[] @relation("ReferralDestinationDoctor")

  // Password Reset Tokens
  passwordResetTokens PasswordResetToken[]

  // WebAuthn / Passkey credentials
  webAuthnCredentials WebAuthnCredential[] @relation("UserWebAuthnCredentials")

  // Schedule Management (New)
  professionalSchedules       ProfessionalSchedule[]    @relation("ProfessionalSchedules")
  requestedSchedules          ProfessionalSchedule[]    @relation("ScheduleRequester")
  approvedSchedules           ProfessionalSchedule[]    @relation("ScheduleApprover")

  // Documento Templates
  createdDocumentTemplates    DocumentTemplate[]        @relation("TemplateCreatedBy")
  generatedDocuments          GeneratedDocument[]       @relation("GeneratedDocsByDoctor")

  // Organização (RO/SST): gestor direto (Manager) e subordinados
  managerUserId String?
  manager       User?   @relation("UserManager", fields: [managerUserId], references: [id], onDelete: SetNull)
  directReports User[]  @relation("UserManager")

  // CFM Compliance - Retenção e Criptografia
  reviewedRetentionPolicies DataRetentionPolicy[]   @relation("RetentionPolicyReviewer")
  acknowledgedRetentionAlerts RetentionAlert[]      @relation("RetentionAlertAcknowledger")
  keyRotations              EncryptionKeyVersion[]  @relation("KeyRotator")

  // Multi-tenancy
  tenants UserTenant[]

  // Medical Record Versioning & Signatures
  medicalRecordVersions   MedicalRecordVersion[]   @relation("MedicalRecordVersions")
  medicalRecordSignatures MedicalRecordSignature[] @relation("MedicalRecordSignatures")
  sharedMedicalRecords    MedicalRecordShare[]     @relation("SharedMedicalRecords")
  grantedMedicalRecordShares MedicalRecordShare[]  @relation("GrantedMedicalRecordShares")

  // Exams
  exams Exam[] @relation("DoctorExams")

  @@index([acsAssignedMicroAreaId])
  @@index([assignedAreaId])
  @@index([managerUserId])
  @@map("users")
}

model PasswordResetToken {
  id                 String   @id @default(cuid())
  userId             String
  user               User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  tokenHash          String   @unique
  expiresAt          DateTime
  usedAt             DateTime?
  requestedIp        String?
  requestedUserAgent String?
  createdAt          DateTime @default(now())

  @@index([userId])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}

// WebAuthn / Passkey credentials
model WebAuthnCredential {
  id            String    @id @default(cuid())
  userId        String
  user          User      @relation("UserWebAuthnCredentials", fields: [userId], references: [id], onDelete: Cascade)
  credentialId  String    @unique // base64url encoded
  publicKey     String    // base64url encoded
  counter       Int       @default(0)
  transports    String?   // comma-separated list: "usb,nfc,ble,internal"
  createdAt     DateTime  @default(now())
  lastUsedAt    DateTime?
  name          String?   // User-friendly name for the device

  @@index([userId])
  @@map("webauthn_credentials")
}

// Tabela para papéis atribuídos a um usuário
// Permite que administradores atribuam papéis adicionais
model UserAssignedRole {
  id         String   @id @default(cuid())
  userId     String
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  role       Role // Papel atribuído (ADMIN, DOCTOR, etc.)
  isPrimary  Boolean  @default(false) // Se é o papel principal
  assignedAt DateTime @default(now())
  assignedBy String? // ID do admin que atribuiu

  @@unique([userId, role]) // Um usuário não pode ter o mesmo papel duas vezes
  @@map("user_assigned_roles")
}

model Person {
  id         String    @id @default(cuid())
  name       String
  socialName String?
  cpf        String?   @unique
  birthDate  DateTime?
  gender     Gender?
  motherName String?
  fatherName String?

  // Contact
  email String?
  phone String?

  // Demographics
  ethnicity      String? // IBGE
  educationLevel String?
  occupation     String?
  nationality    String?

  // System Links
  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])

  // Roles
  patient      Patient?

  // Address

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("people")
}

model Branding {
  id         String   @id @default(cuid())
  clinicName String?
  logoUrl    String?
  headerUrl  String?
  footerText String?
  // Novos campos para melhor estrutura
  clinicPhone String?
  clinicAddress String?
  clinicCity  String?
  clinicState String?
  clinicZipCode String?
  updatedAt  DateTime @updatedAt
  @@map("branding")
}

// Modelo para armazenar templates de documentos customizáveis
model DocumentTemplate {
  id                  String   @id @default(cuid())
  name                String   // Ex: "Prescrição Padrão", "Atestado Médico"
  documentType        String   // prescription, certificate, attestation, etc.
  description         String?
  
  // HTML com placeholders {{variável}}
  htmlTemplate        String   @db.Text
  
  // CSS customizado para o template
  cssTemplate         String?  @db.Text
  
  // Configurações de layout (JSON)
  config              Json?    // { pageSize: "A4", orientation: "portrait", margins: {...}, etc. }
  
  // Elemento para assinatura digital
  signaturePosition   String?  // bottom-right, bottom-left, bottom-center, top-right, etc.
  signatureSize       String?  // small, medium, large
  
  // QR Code
  qrcodePosition      String?  // bottom-right, bottom-left, etc.
  qrcodeSize          String?  // 1cm, 1.5cm, 2cm, etc.
  showQrcode          Boolean  @default(true)
  
  // Dados de clínica inclusos
  clinicName          Boolean  @default(true)
  clinicLogo          Boolean  @default(true)
  clinicAddress       Boolean  @default(true)
  clinicPhone         Boolean  @default(true)
  
  // Dados de médico inclusos
  doctorName          Boolean  @default(true)
  doctorSpec          Boolean  @default(true)
  doctorCRM           Boolean  @default(true)
  doctorAddress       Boolean  @default(false)
  doctorLogo          Boolean  @default(false)
  
  // Rodapé
  showFooter          Boolean  @default(true)
  footerText          String?
  
  // Status
  isActive            Boolean  @default(true)
  isDefault           Boolean  @default(false)
  
  // Auditoria
  createdBy           String
  createdByUser       User     @relation("TemplateCreatedBy", fields: [createdBy], references: [id], onDelete: Cascade)
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  // Documentos gerados com este template
  generatedDocs       GeneratedDocument[]
  
  @@index([documentType])
  @@index([createdBy])
  @@index([isActive])
  @@index([isDefault])
  @@map("document_templates")
}

// Modelo para rastrear documentos gerados com templates
model GeneratedDocument {
  id                  String   @id @default(cuid())
  
  // Template usado
  templateId          String
  template            DocumentTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  
  // Documento original (prescrição, certificado, etc.)
  documentType        String   // prescription, certificate, attestation, etc.
  documentId          String   // ID da prescrição, certificado, atestado, etc.
  
  // Médico
  doctorId            String
  doctor              User     @relation("GeneratedDocsByDoctor", fields: [doctorId], references: [id], onDelete: Cascade)
  
  // Paciente (opcional)
  patientId           String?
  patient             Patient? @relation("GeneratedDocsByPatient", fields: [patientId], references: [id], onDelete: SetNull)
  
  // PDF armazenado (URL ou path)
  pdfUrl              String?
  
  // Assinatura digital
  signedHash          String?
  
  // Relacionamento com documento assinado
  signedDocumentId    String?  @unique
  signedDocument      SignedDocument? @relation(fields: [signedDocumentId], references: [id], onDelete: SetNull)
  
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt
  
  @@index([templateId])
  @@index([documentType, documentId])
  @@index([doctorId])
  @@index([patientId])
  @@index([createdAt])
  @@map("generated_documents")
}

model Patient {
  id                    String                 @id @default(cuid())
  name                  String
  email                 String                 @unique
  cpf                   String?
  birthDate             DateTime
  gender                Gender
  phone                 String?
  address               String?
  emergencyContact      String?
  allergies             String?
  bloodType             String?
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  currentMedications    String?
  insuranceNumber       String?
  medicalHistory        String?
  riskLevel             RiskLevel              @default(BAIXO)
  userId                String?
  latitude              Float?
  longitude             Float?
  cpfHash               String?                @unique
  userAccount           User?                  @relation("UserPatient")
  addresses             Address[]
  attachments           Attachment[]
  consultations         Consultation[]
  diagnoses             Diagnosis[]
  ExamRequest           ExamRequest[]
  examResults           ExamResult[]
  documents             MedicalDocument[]
  medicalRecords        MedicalRecord[]
  User                  User?                  @relation(fields: [userId], references: [id])
  personId              String?                @unique
  person                Person?                @relation(fields: [personId], references: [id])
  prescriptions         Prescription[]
  referrals             Referral[]
  vitalSigns            VitalSigns[]
  pdfExports            PatientPdfExport[]     @relation("PatientPdfExports")

  // Dispositivos de saúde conectados

  // Consentimentos de biometria (LGPD)
  biometricConsents    PatientBiometricConsent[]
  dataDeletionRequests DataDeletionRequest[]
  treatmentOppositions TreatmentOpposition[]

  // Questionários integrativos recebidos
  questionnaires PatientQuestionnaire[]

  // Equipe de cuidado do paciente
  careTeam PatientCareTeam[]

  // Convênios médicos do paciente

  // Fila de espera
  waitingLists WaitingList[]

  // Gravações de teleconsulta
  telemedicineRecordings TelemedicineRecording[]

  // Documentos gerados para este paciente
  generatedDocuments GeneratedDocument[] @relation("GeneratedDocsByPatient")

  // Atestados médicos
  medicalCertificates MedicalCertificate[]

  // NPS enviados
  npsResponses NpsResponse[]

  // Wellness Dashboard - Patient Experience

  // ============================================
  // SSF INTEGRATION - New Relations
  // ============================================

  // Gynecological History

  // Lab Exams
  exams Exam[]
  // ============================================

  // PSF/Família Integration
  rg         String? // RG or equivalent ID
  rgState    String? // State where RG was issued
  fatherName String?

  familyNumber     String? // PSF format: "001.0001.0001"
  sequenceInFamily Int? // Order in family (1, 2, 3...)

  // Social Assessment
  socialVulnerability String? // LOW, MEDIUM, HIGH
  economicClass       String? // A, B, C, D, E
  monthlyFamilyIncome Float? // In BRL

  // Location preference
  preferredAddressId String?
  preferredAddress   Address? @relation("PreferredAddress", fields: [preferredAddressId], references: [id], onDelete: SetNull)

  @@index([familyNumber, sequenceInFamily])
  @@index([preferredAddressId])
  @@index([socialVulnerability])
  @@map("patients")
}

model Referral {
  id          String  @id @default(cuid())
  patientId   String
  doctorId    String
  specialty   String
  description String
  priority    String  @default("NORMAL")
  status      String  @default("PENDING")
  notes       String?

  // ============================================
  // ENHANCED REFERRAL (SSF Integration)
  // ============================================
  // Consulta de origem
  consultationId String?
  consultation   Consultation? @relation("OriginReferral", fields: [consultationId], references: [id])

  // Unidade de destino
  destinationUnitId String?
  destinationUnit   HealthUnit? @relation("ReferralDestinationUnit", fields: [destinationUnitId], references: [id])

  // Profissional de destino
  destinationDoctorId String?
  destinationDoctor   User?   @relation("ReferralDestinationDoctor", fields: [destinationDoctorId], references: [id])

  // Agendamento
  scheduledDate DateTime?
  attendedDate  DateTime?

  // Urgência detalhada
  urgencyLevel String? // ROUTINE, URGENT, EMERGENCY

  // Contra-referência
  counterReferralId String?   @unique
  counterReferral   Referral? @relation("CounterReferral", fields: [counterReferralId], references: [id])
  originReferral    Referral? @relation("CounterReferral")

  // Resultado do encaminhamento
  outcome      String? // ATTENDED, NO_SHOW, CANCELLED, RESOLVED
  outcomeNotes String?
  // ============================================

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  doctor    User     @relation(fields: [doctorId], references: [id])
  patient   Patient  @relation(fields: [patientId], references: [id])

  @@index([consultationId])
  @@index([destinationUnitId])
  @@index([scheduledDate])
  @@index([status])
  @@map("referrals")
}

model MedicalRecord {
  id             String       @id @default(cuid())
  title          String
  description    String
  diagnosis      String?
  treatment      String?
  notes          String?
  recordType     RecordType
  severity       Severity     @default(LOW)
  isPrivate      Boolean      @default(false)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  patientId      String
  doctorId       String
  sourceDocument String?
  deletedAt      DateTime?
  priority       String       @default("NORMAL")
  version        Int          @default(1)
  
  // ============================================
  // CFM 2.218/2018 - Nível de Segurança e Criptografia
  // ============================================
  securityLevel       SecurityLevel @default(NGS1)
  requiresSignature   Boolean       @default(false) // NGS2 exige assinatura ICP-Brasil
  signedDocumentId    String?       // Referência ao documento assinado
  
  // Campos criptografados (AES-256-GCM) - dados sensíveis
  encryptedDiagnosis  String?       @db.Text // Diagnóstico criptografado
  encryptedTreatment  String?       @db.Text // Tratamento criptografado
  encryptedNotes      String?       @db.Text // Notas criptografadas
  
  // Versão da chave de criptografia usada
  encryptionKeyVersion String?      @default("v1")
  
  // Política de retenção - CFM 1.821/2007
  retentionExpiresAt  DateTime?     // Quando pode ser descartado (20+ anos)

  // Tags e status para operações em lote
  tags            String[]          @default([])
  status          String            @default("ACTIVE") // ACTIVE, DRAFT, SIGNED, ARCHIVED
  
  aiAnalysis     AIAnalysis[]
  attachments    Attachment[]
  doctor         User         @relation(fields: [doctorId], references: [id])
  patient        Patient      @relation(fields: [patientId], references: [id])

  // Versioning & Signatures
  versions       MedicalRecordVersion[]
  signatures     MedicalRecordSignature[]
  shares         MedicalRecordShare[]

  @@index([patientId])
  @@index([doctorId])
  @@index([recordType])
  @@index([createdAt])
  @@index([deletedAt])
  @@index([status])
  @@map("medical_records")
}

model Consultation {
  id             String             @id @default(cuid())
  scheduledDate  DateTime
  actualDate     DateTime?
  completedAt    DateTime?
  duration       Int?
  type           ConsultationType
  status         ConsultationStatus @default(SCHEDULED)
  chiefComplaint String?
  history        String?
  physicalExam   String?
  assessment     String?
  plan           String?
  notes          String?
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  patientId      String
  doctorId       String
  meetingLink    String?
  videoUrl       String?

  // ============================================
  // CAMPOS DE BI - TIPO DE ATENDIMENTO (SSF)
  // ============================================
  scheduledDemand     Boolean @default(false) // Demanda Agendada
  immediateDemand     Boolean @default(false) // Demanda Imediata
  orientationOnly     Boolean @default(false) // Atendimento para Orientação
  urgencyWithObs      Boolean @default(false) // Urgência com Observação
  continuedCare       Boolean @default(false) // Atendimento Continuado
  prescriptionRenewal Boolean @default(false) // Renovação de Receita
  examEvaluation      Boolean @default(false) // Avaliação de Exame
  homeVisit           Boolean @default(false) // Visita Domiciliar

  // ============================================
  // CAMPOS DE BI - GRUPOS DE ATENDIMENTO (SSF)
  // ============================================
  mentalHealth Boolean @default(false) // Saúde Mental
  alcoholUser  Boolean @default(false) // Usuário de Álcool
  drugUser     Boolean @default(false) // Usuário de Drogas
  hypertension Boolean @default(false) // Hipertensão
  diabetes     Boolean @default(false) // Diabetes
  leprosy      Boolean @default(false) // Hanseníase
  tuberculosis Boolean @default(false) // Tuberculose
  prenatal     Boolean @default(false) // Pré-Natal
  postpartum   Boolean @default(false) // Puerpério
  stdAids      Boolean @default(false) // DST/AIDS
  preventive   Boolean @default(false) // Preventivo
  childCare    Boolean @default(false) // Puericultura

  // ============================================
  // CAMPOS DE BI - CONDUTAS (SSF)
  // ============================================
  laboratory          Boolean @default(false) // Laboratório
  radiology           Boolean @default(false) // Radiologia
  ultrasound          Boolean @default(false) // Ecografia
  obstetricUltrasound Boolean @default(false) // Ecografia Obstétrica
  mammography         Boolean @default(false) // Mamografia
  ecg                 Boolean @default(false) // ECG
  pathology           Boolean @default(false) // Patologia
  physiotherapy       Boolean @default(false) // Fisioterapia
  referralMade        Boolean @default(false) // Referência

  // ============================================
  // RELAÇÕES
  // ============================================
  doctor               User                  @relation(fields: [doctorId], references: [id])
  patient              Patient               @relation(fields: [patientId], references: [id])
  diagnoses            Diagnosis[]
  examRequests         ExamRequest[]
  prescriptions        Prescription[]
  vitalSigns           VitalSigns[]

  // Questionários associados a esta consulta
  questionnaires PatientQuestionnaire[]

  // Fila de espera atendida
  waitingList WaitingList?

  // Gravações de telemedicina
  telemedicineRecordings TelemedicineRecording[]

  // Atestados emitidos
  medicalCertificates MedicalCertificate[]

  // NPS da consulta
  npsResponse NpsResponse?

  // Assinaturas (imagem) vinculadas à teleconsulta

  // ============================================
  // SSF INTEGRATION - New Relations
  // ============================================
  // Prenatal consultation

  // Gynecological history

  // Referrals originated from this consultation
  originReferrals Referral[] @relation("OriginReferral")
  // ============================================

  // Recursos reservados para esta consulta (sala, equipamentos)

  @@map("consultations")
}

model Prescription {
  id               String             @id @default(cuid())
  medication       String
  dosage           String
  frequency        String
  duration         String
  instructions     String?
  status           PrescriptionStatus @default(ACTIVE)
  startDate        DateTime           @default(now())
  endDate          DateTime?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  patientId        String
  doctorId         String
  consultationId   String?
  digitalSignature String?
  
  // ============================================
  // CAMPOS CFM/ANVISA 2026 - Prescrições Controladas
  // ============================================
  
  // Tipo de receituário (determina layout, validade, numeração)
  prescriptionType PrescriptionType   @default(SIMPLE)
  
  // Numeração obrigatória para receitas controladas (fornecida pela Vigilância Sanitária)
  // Formato: A-123456789-SP, B-987654321-RJ, etc
  controlNumber    String?            @unique
  
  // UF da receita (estado onde foi emitida)
  uf               String?            @db.VarChar(2)
  
  // Data de validade (calculada conforme tipo de receita)
  expiresAt        DateTime?
  
  // Identificação completa do comprador (obrigatória para controladas)
  buyerName        String?
  buyerDocument    String?            // CPF ou RG
  buyerAddress     String?
  buyerPhone       String?
  
  // Dispensação (preenchido pela farmácia)
  dispensedAt      DateTime?
  pharmacyName     String?
  pharmacyCnpj     String?
  pharmacistName   String?
  pharmacistCrf    String?
  
  // Via da receita (1ª VIA = farmácia, 2ª VIA = paciente)
  viaNumber        Int?               @default(1)
  
  // Justificativa (para receitas A e B)
  justification    String?            @db.Text
  
  // Flags de controle
  requiresSecondCopy Boolean          @default(false) // Antibióticos, controlados
  hasRestrictedQuantity Boolean       @default(false) // Lista A (máx 5 ampolas)
  
  // ============================================
  
  consultation     Consultation?      @relation(fields: [consultationId], references: [id])
  doctor           User               @relation(fields: [doctorId], references: [id])
  patient          Patient            @relation(fields: [patientId], references: [id])
  items            PrescriptionItem[]

  @@index([prescriptionType])
  @@index([controlNumber])
  @@index([expiresAt])
  @@map("prescriptions")
}

enum PrescriptionType {
  SIMPLE          // Receita simples (branca, 1 via)
  ANTIMICROBIAL   // Antibiótico (branca, 2 vias, validade 10 dias)
  CONTROLLED_A    // Notificação A (amarela, 2 vias, entorpecentes)
  CONTROLLED_B    // Notificação B (azul, 2 vias, psicotrópicos)
  CONTROLLED_C1   // Receita C1 (branca, 2 vias, outras controladas)
  CONTROLLED_C4   // Receita C4 (branca, 2 vias, antiretrovirais - validade 6 meses)
  CONTROLLED_C5   // Receita C5 (branca, 2 vias, anabolizantes)
}

model ExamRequest {
  id             String        @id @default(cuid())
  examType       String
  description    String?
  urgency        Urgency       @default(ROUTINE)
  status         ExamStatus    @default(REQUESTED)
  requestDate    DateTime      @default(now())
  scheduledDate  DateTime?
  completedDate  DateTime?
  results        String?
  notes          String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  patientId      String
  doctorId       String
  consultationId String?
  attachments    Attachment[]
  consultation   Consultation? @relation(fields: [consultationId], references: [id])
  doctor         User          @relation(fields: [doctorId], references: [id])
  patient        Patient       @relation(fields: [patientId], references: [id])

  @@map("exam_requests")
}

model VitalSigns {
  id               String @id @default(cuid())
  systolicBP       Int?
  diastolicBP      Int?
  heartRate        Int?
  respiratoryRate  Int?
  temperature      Float?
  weight           Float? // Peso em kg
  height           Float? // Altura em cm
  bmi              Float? // IMC calculado
  oxygenSaturation Int?
  bloodGlucose     Int?

  // ============================================
  // ANTHROPOMETRIC MEASUREMENTS (SSF Integration)
  // ============================================
  waistCircumference Float? // Circunferência da cintura (cm)
  hipCircumference   Float? // Circunferência do quadril (cm)
  headCircumference  Float? // Perímetro cefálico (cm) - pediatria
  armCircumference   Float? // Circunferência do braço (cm)

  // BMI Classification
  bmiClassification String? // UNDERWEIGHT, NORMAL, OVERWEIGHT, OBESE_I, OBESE_II, OBESE_III

  // Pediatric specific
  breastfeeding String? // EXCLUSIVE, PREDOMINANT, COMPLEMENTARY, NONE
  weightForAge  String? // Classificação peso/idade (OMS)
  heightForAge  String? // Classificação altura/idade (OMS)
  bmiForAge     String? // Classificação IMC/idade (OMS)

  // Nutritional assessment
  nutritionalStatus String? // NORMAL, MILD_MALNUTRITION, MODERATE_MALNUTRITION, SEVERE_MALNUTRITION, OVERWEIGHT, OBESITY
  // ============================================

  notes          String?
  recordedAt     DateTime      @default(now())
  createdAt      DateTime      @default(now())
  patientId      String
  consultationId String?
  consultation   Consultation? @relation(fields: [consultationId], references: [id])
  patient        Patient       @relation(fields: [patientId], references: [id])

  @@map("vital_signs")
}

model Attachment {
  id              String         @id @default(cuid())
  fileName        String
  originalName    String
  fileSize        Int
  mimeType        String
  filePath        String
  description     String?
  createdAt       DateTime       @default(now())
  medicalRecordId String?
  examRequestId   String?
  patientId       String?
  examRequest     ExamRequest?   @relation(fields: [examRequestId], references: [id])
  medicalRecord   MedicalRecord? @relation(fields: [medicalRecordId], references: [id])
  Patient         Patient?       @relation(fields: [patientId], references: [id])

  @@map("attachments")
}

model MedicalDocument {
  id            String                @id @default(cuid())
  fileName      String
  content       String
  fileType      DocumentFileType
  status        DocumentProcessStatus @default(PENDING)
  uploadDate    DateTime              @default(now())
  errorMessage  String?
  importResults String?
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  patientId     String?
  analysis      DocumentAnalysis?
  patient       Patient?              @relation(fields: [patientId], references: [id])

  @@map("medical_documents")
}

model DocumentAnalysis {
  id               String          @id @default(cuid())
  confidence       Float
  documentType     DocumentType
  patientInfo      String
  extractedData    String
  suggestedActions String
  analysisDate     DateTime        @default(now())
  reviewed         Boolean         @default(false)
  reviewedBy       String?
  reviewedAt       DateTime?
  documentId       String          @unique
  document         MedicalDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@map("document_analysis")
}

model ExamResult {
  id             String   @id @default(cuid())
  examType       String
  results        String
  examDate       DateTime
  sourceDocument String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  patientId      String
  patient        Patient  @relation(fields: [patientId], references: [id])

  @@map("exam_results")
}

model Address {
  id           String   @id @default(cuid())
  street       String
  number       String?
  complement   String?
  neighborhood String? // Keep for backward compatibility
  city         String // Keep for backward compatibility
  state        String // Keep for backward compatibility
  zipCode      String?
  latitude     Float?
  longitude    Float?
  isPrimary    Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Old references (backward compatibility)
  patientId   String?
  microAreaId String?

  // New geographic hierarchy (all optional for backward compatibility)
  areaId          String?

  // Relations - old
  patient            Patient?        @relation(fields: [patientId], references: [id])
  microArea          MicroArea?      @relation(fields: [microAreaId], references: [id])
  Place              Place[]
  patientsPreferring Patient[]       @relation("PreferredAddress")

  // Relations - new geographic
  area            Area?          @relation(fields: [areaId], references: [id], onDelete: SetNull)

  @@index([patientId])
  @@index([microAreaId])
  @@index([areaId])
  @@index([latitude, longitude])
  @@map("addresses")
}

model Place {
  id          String     @id @default(cuid())
  name        String
  description String?
  category    String?
  latitude    Float?
  longitude   Float?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  addressId   String?
  microAreaId String?
  address     Address?   @relation(fields: [addressId], references: [id])
  microArea   MicroArea? @relation(fields: [microAreaId], references: [id])

  @@index([microAreaId])
  @@index([latitude, longitude])
  @@map("places")
}

model MicroArea {
  id          String   @id @default(cuid())
  name        String
  code        String?  @unique
  description String?
  polygonGeo  String?
  centroidLat Float?
  centroidLng Float?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  maxLat      Float?
  maxLng      Float?
  minLat      Float?
  minLng      Float?

  // Geographic hierarchy
  areaId String?
  area   Area?   @relation(fields: [areaId], references: [id], onDelete: SetNull)

  // ACS assignments
  acsUsers   User[]       @relation("ACSMicroArea")

  addresses Address[]
  places    Place[]

  @@index([areaId])
  @@index([centroidLat, centroidLng])
  @@index([minLat, maxLat])
  @@index([minLng, maxLng])
  @@map("micro_areas")
}

model CodeSystem {
  id          String         @id @default(cuid())
  kind        CodeSystemKind
  name        String
  version     String?
  description String?
  active      Boolean        @default(true)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  codes       MedicalCode[]

  @@unique([kind, version])
  @@map("code_systems")
}

model MedicalCode {
  id                String                   @id @default(cuid())
  systemId          String
  code              String
  display           String
  description       String?
  parentId          String?
  synonyms          String?
  searchableText    String?
  active            Boolean                  @default(true)
  // Campos adicionais do sistema legado SSF
  chapter           String? // Capítulo CID-10 (I-XXII)
  isCategory        Boolean                  @default(false) // Se é categoria principal
  sexRestriction    String? // M=masculino, F=feminino, null=ambos
  crossAsterisk     String? // ETIOLOGY (+) ou MANIFESTATION (*)
  shortDescription  String? // Descrição curta/abreviada
  createdAt         DateTime                 @default(now())
  updatedAt         DateTime                 @updatedAt
  primaryIn         Diagnosis[]              @relation("PrimaryCode")
  parent            MedicalCode?             @relation("MedicalCodeHierarchy", fields: [parentId], references: [id])
  children          MedicalCode[]            @relation("MedicalCodeHierarchy")
  system            CodeSystem               @relation(fields: [systemId], references: [id])

  @@unique([systemId, code])
  @@index([code])
  @@index([display])
  @@index([chapter])
  @@index([sexRestriction])
  @@map("medical_codes")
}

model Diagnosis {
  id             String                   @id @default(cuid())
  patientId      String
  consultationId String?
  primaryCodeId  String
  status         DiagnosisStatus          @default(ACTIVE)
  certainty      DiagnosisCertainty       @default(CONFIRMED)
  notes          String?
  onsetDate      DateTime?
  resolvedDate   DateTime?
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt
  consultation   Consultation?            @relation(fields: [consultationId], references: [id])
  patient        Patient                  @relation(fields: [patientId], references: [id])
  primaryCode    MedicalCode              @relation("PrimaryCode", fields: [primaryCodeId], references: [id])
  revisions      DiagnosisRevision[]

  @@index([patientId])
  @@index([consultationId])
  @@map("diagnoses")
}

model DiagnosisRevision {
  id              String    @id @default(cuid())
  diagnosisId     String
  previous        Json?
  next            Json?
  changedAt       DateTime  @default(now())
  changedByUserId String?
  reason          String?
  diagnosis       Diagnosis @relation(fields: [diagnosisId], references: [id])

  @@index([diagnosisId, changedAt])
  @@map("diagnosis_revisions")
}

model AIInteraction {
  id         String        @id @default(cuid())
  type       AIRequestType
  prompt     String
  response   String
  confidence Float?
  metadata   Json?
  createdAt  DateTime      @default(now())
  userId     String
  user       User          @relation(fields: [userId], references: [id])

  @@map("ai_interactions")
}

model AIAnalysis {
  id              String        @id @default(cuid())
  analysisType    String
  input           String
  result          String
  confidence      Float
  suggestions     String[]
  metadata        Json?
  createdAt       DateTime      @default(now())
  medicalRecordId String
  medicalRecord   MedicalRecord @relation(fields: [medicalRecordId], references: [id])

  @@map("ai_analysis")
}

model AIQuotaUsage {
  id        String   @id @default(cuid())
  userId    String
  type      String
  date      DateTime
  count     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, type, date])
  @@index([type, date])
  @@map("ai_quota_usage")
}

model AuditLog {
  id           String   @id @default(cuid())
  userId       String
  userEmail    String
  userRole     String
  action       String
  resourceId   String?
  ipAddress    String?
  userAgent    String?
  success      Boolean  @default(true)
  errorMessage String?
  createdAt    DateTime @default(now())
  changes      Json?
  metadata     Json?
  resourceType String   @default("MEDICAL_RECORD")

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@index([resourceId, createdAt])
  @@index([resourceType, createdAt])
  @@index([success, createdAt])
  @@map("audit_logs")
}

model ExternalSourceUpdate {
  id            String             @id @default(cuid())
  sourceType    ExternalSourceType
  versionTag    String?
  status        String
  startedAt     DateTime           @default(now())
  finishedAt    DateTime?
  fetchedCount  Int                @default(0)
  insertedCount Int                @default(0)
  updatedCount  Int                @default(0)
  skippedCount  Int                @default(0)
  checksum      String?
  errorMessage  String?
  meta          String?
  retiredCount  Int                @default(0)

  @@index([sourceType, startedAt])
  @@map("external_source_updates")
}

model CBOGroup {
  id          String       @id @default(cuid())
  code        String       @unique
  name        String
  level       Int
  parentId    String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  parent      CBOGroup?    @relation("CBOGroupHierarchy", fields: [parentId], references: [id])
  children    CBOGroup[]   @relation("CBOGroupHierarchy")
  occupations Occupation[]

  @@index([level])
  @@map("cbo_groups")
}

model Occupation {
  id          String    @id @default(cuid())
  code        String    @unique
  title       String
  description String?
  groupId     String?
  synonyms    String?
  active      Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  group       CBOGroup? @relation(fields: [groupId], references: [id])

  @@index([groupId])
  @@map("occupations")
}

// ========================================
// STRATUM ASSESSMENT SYSTEM (Elliott Jaques)
// ========================================

// Questionário de avaliação de Time Span
// Banco de questões para avaliação
// Perfil de cargo com requisitos de estrato detalhados
// ========================================
// CHARACTER STRENGTHS & GEMS SYSTEM
// ========================================

// Forças de Caráter (baseado no VIA Survey)
// Questões para avaliação de forças
// Plano de Desenvolvimento Pessoal
model ScheduleException {
  id          String   @id @default(cuid())
  doctorId    String
  date        DateTime
  blockType   BlockType @default(UNAVAILABLE) // Tipo de bloqueio
  reason      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  doctor      User     @relation(fields: [doctorId], references: [id])

  @@index([doctorId, date])
  @@map("schedule_exceptions")
}

enum BlockType {
  UNAVAILABLE    // Indisponível geral
  ON_CALL        // Plantão (em outro serviço)
  VACATION       // Férias
  SICK_LEAVE     // Licença médica
  MAINTENANCE    // Manutenção/admin
  TRAINING       // Treinamento
  MEETING        // Reunião/conferência
}

model Notification {
  id        String    @id @default(cuid())
  userId    String
  type      String
  priority  String    @default("low")
  title     String
  message   String
  read      Boolean   @default(false)
  metadata  Json?
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id])

  @@index([userId, read])
  @@index([userId, createdAt])
  @@map("notifications")
}

// Notificações Enviadas por Canais (Email, WhatsApp, SMS, Push)
model SentNotification {
  id              String    @id @default(cuid())
  type            String    // appointment_confirmation, appointment_reminder, etc.
  channel         String    // email, whatsapp, push, sms
  recipientId     String    // userId ou patientId
  recipientType   String    // USER ou PATIENT
  recipientName   String
  recipientContact String?  // email ou telefone usado
  status          String    @default("PENDING") // PENDING, SENT, DELIVERED, FAILED, READ
  templateData    Json?     // Dados usados no template
  error           String?   // Mensagem de erro se falhou
  messageId       String?   // ID da mensagem no provedor (WhatsApp, email)
  sentAt          DateTime?
  deliveredAt     DateTime?
  readAt          DateTime?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([recipientId, type])
  @@index([channel, status])
  @@index([sentAt])
  @@map("sent_notifications")
}

model CIAP2 {
  code        String  @id
  description String
  chapter     String
  gender      String?
  active      Boolean @default(true)

  @@map("ciap2")
}

model Territory {
  id       String      @id @default(cuid())
  name     String
  type     String // 'MUNICIPALITY', 'DISTRICT', 'UNIT', 'TEAM_AREA', 'MICRO_AREA'
  parentId String?
  parent   Territory?  @relation("TerritoryHierarchy", fields: [parentId], references: [id])
  children Territory[] @relation("TerritoryHierarchy")

  // GeoJSON geometry stored as JSON
  geometry Json?

  // Center point for quick lookup
  centerLat Float?
  centerLng Float?

  // Hierarchy
  level Int? // 1=Municipality, 2=District, 3=Subprefecture, 4=Area, 5=MicroArea

  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([type])
  @@index([parentId])
  @@map("territories")
}

enum DocumentFileType {
  DOCX
  DOC
  PDF
  TXT
  RTF
}

enum DocumentProcessStatus {
  PENDING
  ANALYZING
  CLASSIFIED
  IMPORTED
  ERROR
}

enum DocumentType {
  EVOLUCAO
  EXAME
  PRESCRICAO
  ANAMNESE
  ATESTADO
  RECEITA
  LAUDO
  OUTROS
}

enum Role {
  ADMIN
  DOCTOR
  NURSE
  RECEPTIONIST
  PHYSIOTHERAPIST
  PSYCHOLOGIST
  HEALTH_AGENT
  TECHNICIAN
  PHARMACIST
  DENTIST
  NUTRITIONIST
  SOCIAL_WORKER
  OTHER
  PATIENT
}

enum InviteStatus {
  PENDING
  USED
  EXPIRED
}

enum TermAudience {
  ALL
  PATIENT
  PROFESSIONAL
}

model Term {
  id       String  @id @default(cuid())
  slug     String
  title    String
  content  String  @db.Text
  version  String
  isActive Boolean @default(true)

  audience TermAudience @default(ALL)

  acceptances TermAcceptance[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([slug, version])

  @@map("terms")
}

model TermAcceptance {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])
  termId String
  term   Term   @relation(fields: [termId], references: [id])

  // Snapshot auditável do termo aceito (mantém evidência mesmo após atualizações)
  termSlug    String?
  termTitle   String?
  termVersion String?
  termContent String? @db.Text

  acceptedAt DateTime @default(now())
  ipAddress  String?
  userAgent  String?

  @@map("term_acceptances")
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum RiskLevel {
  BAIXO
  MEDIO
  ALTO
  CRITICO
}

enum BloodType {
  A_POSITIVE
  A_NEGATIVE
  B_POSITIVE
  B_NEGATIVE
  AB_POSITIVE
  AB_NEGATIVE
  O_POSITIVE
  O_NEGATIVE
}

enum RecordType {
  CONSULTATION
  EXAM
  PRESCRIPTION
  DIAGNOSIS
  TREATMENT
  SURGERY
  EMERGENCY
  FOLLOW_UP
}

enum Severity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

// ============================================
// CFM Resolução 2.218/2018 - Níveis de Garantia de Segurança
// NGS1: Prontuários com assinatura simples (backup, integridade)
// NGS2: Prontuários com assinatura digital ICP-Brasil (validade jurídica plena)
// ============================================
enum SecurityLevel {
  NGS1 // Nível de Garantia de Segurança 1 - Assinatura simples
  NGS2 // Nível de Garantia de Segurança 2 - ICP-Brasil obrigatório
}

// ============================================
// Política de Retenção de Dados - CFM Resolução 1.821/2007
// Prontuários médicos devem ser mantidos por no mínimo 20 anos
// após último atendimento, ou até paciente completar 21 anos
// ============================================
model DataRetentionPolicy {
  id String @id @default(cuid())

  // Tipo de documento
  documentType      RetentionDocumentType
  retentionYears    Int                   @default(20) // Mínimo CFM: 20 anos
  
  // Configurações de alerta
  alertThresholdDays Int @default(365) // Alertar 1 ano antes de expirar
  
  // Status de revisão
  lastReviewDate    DateTime?
  nextReviewDate    DateTime?
  reviewedById      String?
  reviewedBy        User?               @relation("RetentionPolicyReviewer", fields: [reviewedById], references: [id])
  
  // Descrição e justificativa legal
  legalBasis        String              @default("CFM Resolução 1.821/2007")
  description       String?             @db.Text
  
  // Metadados
  isActive          Boolean             @default(true)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt

  @@unique([documentType])
  @@map("data_retention_policies")
}

enum RetentionDocumentType {
  MEDICAL_RECORD      // Prontuário - 20 anos CFM
  PRESCRIPTION        // Prescrição - 5 anos
  EXAM_RESULT         // Exame - 20 anos
  MEDICAL_CERTIFICATE // Atestado - 20 anos
  CONSENT_FORM        // TCLE - 5 anos após término
  REFERRAL            // Encaminhamento - 20 anos
  TELECONSULTATION    // Teleconsulta - 20 anos
  AUDIT_LOG           // Logs de auditoria - 5 anos LGPD
  FINANCIAL           // Financeiro - 5 anos fiscal
}

// ============================================
// Alertas de Retenção - Documentos próximos de expirar
// ============================================
model RetentionAlert {
  id String @id @default(cuid())

  // Documento referenciado
  documentType  RetentionDocumentType
  documentId    String
  patientId     String?
  
  // Datas
  documentDate  DateTime // Data do documento original
  expirationDate DateTime // Data de expiração calculada
  
  // Status
  status        RetentionAlertStatus @default(PENDING)
  acknowledgedAt DateTime?
  acknowledgedById String?
  acknowledgedBy   User?            @relation("RetentionAlertAcknowledger", fields: [acknowledgedById], references: [id])
  
  // Ação tomada
  actionTaken   String?             @db.Text
  
  // Metadados
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt

  @@index([documentType, status])
  @@index([expirationDate])
  @@index([patientId])
  @@map("retention_alerts")
}

enum RetentionAlertStatus {
  PENDING       // Aguardando revisão
  ACKNOWLEDGED  // Reconhecido
  EXTENDED      // Prazo estendido
  ARCHIVED      // Arquivado conforme política
  DELETED       // Deletado após período legal
}

// ============================================
// Rotação de Chaves de Criptografia
// ============================================
model EncryptionKeyVersion {
  id String @id @default(cuid())

  // Identificador da chave
  keyIdentifier String   @unique // Formato: "key_v1", "key_v2", etc.
  version       Int
  
  // Status
  status        KeyStatus @default(ACTIVE)
  
  // Hash da chave para verificação (não armazena a chave!)
  keyHash       String    // SHA-256 do prefixo da chave para verificação
  algorithm     String    @default("aes-256-gcm")
  
  // Datas
  activatedAt   DateTime  @default(now())
  rotatedAt     DateTime? // Quando foi rotacionada
  expiresAt     DateTime? // Data de expiração planejada
  
  // Metadados de rotação
  rotatedById   String?
  rotatedBy     User?     @relation("KeyRotator", fields: [rotatedById], references: [id])
  rotationReason String?
  
  // Auditoria
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([status])
  @@index([version])
  @@map("encryption_key_versions")
}

enum KeyStatus {
  ACTIVE      // Chave em uso para criptografia
  DECRYPT_ONLY // Apenas para descriptografar dados antigos
  EXPIRED     // Expirada, não usar
  REVOKED     // Revogada por segurança
}

enum ConsultationType {
  INITIAL
  FOLLOW_UP
  EMERGENCY
  ROUTINE
  SPECIALIST
}

enum ConsultationStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum PrescriptionStatus {
  ACTIVE
  COMPLETED
  CANCELLED
  EXPIRED
}

enum ExamStatus {
  REQUESTED
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum Urgency {
  ROUTINE
  URGENT
  EMERGENCY
}

enum AIRequestType {
  DIAGNOSIS_SUGGESTION
  TREATMENT_RECOMMENDATION
  DRUG_INTERACTION_CHECK
  SYMPTOM_ANALYSIS
  MEDICAL_SUMMARY
  RISK_ASSESSMENT
}

enum CodeSystemKind {
  CID10
  CID11
  CIAP2
  NURSING
}

enum DiagnosisStatus {
  ACTIVE
  RESOLVED
  ENTERED_IN_ERROR
  INACTIVE
}

enum DiagnosisCertainty {
  SUSPECTED
  PROBABLE
  CONFIRMED
  RULED_OUT
}

enum ExternalSourceType {
  ICD10
  ICD11
  CIAP2
  NURSING
  CBO
}

enum StratumLevel {
  S1
  S2
  S3
  S4
  S5
  S6
  S7
  S8
}

enum TransactionType {
  INCOME
  EXPENSE
}

enum TransactionStatus {
  PENDING
  PAID
  CANCELLED
  OVERDUE
}

enum InsuranceType {
  PRIVATE // Convênio particular
  SUS // Sistema Único de Saúde
  CORPORATE // Convênio empresarial
  OTHER
}

model SystemSetting {
  key         String   @id
  value       String   @db.Text // Suporte a valores grandes
  description String?
  category    String   @default("GENERAL") // EMAIL, SECURITY, SYSTEM, STORAGE, WHATSAPP, REDIS, WEBRTC
  isPublic    Boolean  @default(false)
  encrypted   Boolean  @default(false) // Se o valor está criptografado
  updatedBy   String? // ID do usuário que atualizou
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([category])
  @@map("system_settings")
}

// ==================== HR MANAGEMENT ====================

// Tipos de ausência
// Status da solicitação de ausência
// Solicitação de férias/folgas/licenças
// Tipo de turno
// Escala de trabalho
// Entrada na escala (profissional + turno + data)
// ==================== INVENTORY MANAGEMENT ====================

// Unidade de medida
// Produto/Material
// Tipo de movimentação
// Localização/Almoxarifado
// Estoque (quantidade por localização)
// Movimentação de estoque
// =====================================================
// RECURSOS FÍSICOS (Salas, Equipamentos)
// =====================================================

// Fornecedor
// Status de pedido de compra
enum PurchaseOrderStatus {
  DRAFT // Rascunho
  PENDING // Aguardando aprovação
  APPROVED // Aprovado
  ORDERED // Pedido feito
  PARTIAL // Recebido parcialmente
  RECEIVED // Recebido
  CANCELLED // Cancelado
}

// =====================================================
// SISTEMA DE MEDICAMENTOS (Importado do SSF)
// =====================================================

model Medication {
  id        String  @id @default(cuid())
  name      String // Nome do medicamento
  synonym   String? // Sinônimo / nome alternativo
  tradeName String? // Nome comercial / fantasia

  // Classificação da receita
  prescriptionType PrescriptionType @default(SIMPLE)

  // Disponibilidade nas farmácias
  basicPharmacy      Boolean @default(false) // Farmácia da Unidade
  municipalPharmacy  Boolean @default(false) // Farmácia Municipal
  statePharmacy      Boolean @default(false) // Farmácia Estadual
  homePharmacy       Boolean @default(false) // Internação Domiciliar
  popularPharmacy    Boolean @default(false) // Farmácia Popular
  hospitalPharmacy   Boolean @default(false) // Farmácia Hospitalar
  commercialPharmacy Boolean @default(false) // Farmácia Comercial
  compoundPharmacy   Boolean @default(false) // Farmácia de Manipulação

  // Código SUS
  susCode String?

  // Informações de uso
  instructions String? // Orientação de uso padrão
  notes        String? // Notas
  description  String? // Descrição
  warnings     String? // Advertências
  interactions String? // Interações medicamentosas
  observations String? // Observações

  // Restrições
  minAge         Int? // Idade mínima
  maxAge         Int? // Idade máxima
  sexRestriction String? // M=masculino, F=feminino, null=ambos
  validityDays   Int? // Validade em dias

  // Informações da apresentação
  route       String? // Via de administração (Oral, IM, etc)
  strength    String? // Concentração (ex: 500mg)
  unit        String? // Unidade (mg, mL, etc)
  form        String? // Forma farmacêutica (comprimido, solução, etc)
  packaging   String? // Recipiente (cp, fr, amp, tb, etc)
  packageSize Int? // Capacidade do recipiente

  // Dosagem padrão
  dosePerKg         Float? // Dose por kg
  maxDailyDosePerKg Float? // Dose máxima diária por kg
  defaultFrequency  Float? // Frequência padrão
  defaultDuration   Int? // Duração padrão do tratamento
  maxQuantity       Float? // Quantidade máxima

  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  prescriptionItems     PrescriptionItem[]

  @@index([name])
  @@index([susCode])
  @@map("medications")
}

model PrescriptionItem {
  id             String  @id @default(cuid())
  prescriptionId String
  medicationId   String?

  // Se não usar medicação do catálogo
  customName String?

  // ============================================
  // CAMPOS OBRIGATÓRIOS CFM/ANVISA
  // ============================================
  
  // Nome do medicamento (DCB ou genérico)
  medicationName String
  
  // Concentração/dosagem (ex: 500mg, 10mg/mL)
  concentration  String
  
  // Forma farmacêutica (comprimido, cápsula, solução, etc)
  pharmaceuticalForm String?
  
  // Quantidade numérica
  quantity       Int
  
  // Quantidade por extenso (OBRIGATÓRIA para controladas)
  // Ex: "trinta comprimidos"
  quantityInWords String?
  
  // Posologia detalhada
  dosage         String
  frequency      String
  duration       String
  instructions   String?
  
  // Via de administração (oral, tópica, intravenosa, etc)
  administrationRoute String? @default("oral")
  
  // Uso (interno/externo)
  usageType      String? @default("internal") // internal, external
  
  // ============================================
  
  prescription      Prescription       @relation(fields: [prescriptionId], references: [id], onDelete: Cascade)
  medication        Medication?        @relation(fields: [medicationId], references: [id])

  createdAt DateTime @default(now())

  @@map("prescription_items")
}

// =====================================================
// FÓRMULAS MAGISTRAIS (Templates de Manipulação)
// =====================================================

model FormulaTemplate {
  id          String  @id @default(cuid())
  name        String // Nome da fórmula
  category    String // Categoria (Endocrinologia, Gastrointestinal, etc)
  ingredients String // Ingredientes com doses (Vitamina D3 10.000 UI | K2 120 mcg)
  form        String // Forma farmacêutica (Cápsula, Solução, Creme, etc)
  dosage      String // Posologia sugerida
  notes       String? // Notas técnicas

  // Informações clínicas expandidas (do PDF)
  indications       String? // Indicações clínicas
  contraindications String? // Contraindicações
  sideEffects       String? // Efeitos adversos
  interactions      String? // Interações medicamentosas
  monitoring        String? // Exames/monitoramento recomendado
  duration          String? // Duração sugerida do tratamento

  // Metadados
  source   String? // Fonte (Singularis, Vitalis, CSV, etc)
  pharmacy String? // Farmácia recomendada

  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([name])
  @@index([category])
  @@map("formula_templates")
}

// =====================================================
// SISTEMA DE PROCEDIMENTOS SIGTAP (Importado do SSF)
// =====================================================

model Procedure {
  id             String  @id @default(cuid())
  code           String  @unique // Código SIGTAP (10 dígitos)
  name           String
  complexity     Int? // Complexidade (0-3)
  financing      String? // Financiamento (N=Nacional, I=Municipal, F=Federal)
  minAge         Int? // Idade mínima (em meses)
  maxAge         Int? // Idade máxima (em meses)
  sexRestriction String? // M=masculino, F=feminino, null=ambos

  // Agrupamentos
  group    String? // Grupo do procedimento
  subgroup String? // Subgrupo

  // CBO relacionado
  cboRequired String? // CBO necessário para realizar

  active    Boolean   @default(true)
  validFrom DateTime? // Data de vigência
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([code])
  @@index([name])
  @@map("procedures")
}

// =====================================================
// CATÁLOGO DE EXAMES (Importado do SSF)
// =====================================================

model ExamCatalog {
  id           String  @id @default(cuid())
  name         String
  abbreviation String? // Abreviação (ex: HMG, GLI)
  description  String?

  // Tipo de exame
  examCategory ExamCategory

  // Restrições
  minAge         Int?
  maxAge         Int?
  sexRestriction String? // M=masculino, F=feminino, null=ambos

  // Código SUS relacionado
  susCode String?

  // Preparação
  preparation String? // Instruções de preparo

  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  examComboItems ExamComboItem[] // Combos que incluem este exame

  @@index([name])
  @@index([examCategory])
  @@map("exam_catalog")
}

// ============================================
// COMBOS/PACOTES DE EXAMES
// ============================================

model ExamCombo {
  id          String        @id @default(cuid())
  name        String // Nome do combo (ex: "Check-up Básico", "Perfil Lipídico")
  description String? // Descrição do combo
  category    ExamCategory? // Categoria principal do combo

  // Configurações
  isActive Boolean @default(true)
  isPublic Boolean @default(true) // Disponível para todos os médicos

  // Criador (opcional - combos do sistema não têm criador)
  createdById String?
  createdBy   User?   @relation(fields: [createdById], references: [id])

  // Exames do combo
  items ExamComboItem[]

  // Metadados
  usageCount Int      @default(0) // Quantas vezes foi usado
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([name])
  @@index([category])
  @@index([isActive])
  @@map("exam_combos")
}

model ExamComboItem {
  id String @id @default(cuid())

  // Relacionamentos
  comboId String
  combo   ExamCombo @relation(fields: [comboId], references: [id], onDelete: Cascade)

  examId String
  exam   ExamCatalog @relation(fields: [examId], references: [id], onDelete: Cascade)

  // Ordem do exame no combo
  order Int @default(0)

  // Configurações específicas
  notes      String? // Notas específicas para este exame no combo
  isRequired Boolean @default(true) // Se o exame é obrigatório ou opcional

  createdAt DateTime @default(now())

  @@unique([comboId, examId]) // Um exame só pode estar uma vez em cada combo
  @@index([comboId])
  @@index([examId])
  @@map("exam_combo_items")
}

enum ExamCategory {
  LABORATORY // Laboratório
  RADIOLOGY // Radiografia
  ECG // Eletrocardiograma
  PHYSIOTHERAPY // Fisioterapia
  APAC // APAC
  CYTOPATHOLOGY // Citopatológico
  MAMMOGRAPHY // Mamografia
  ULTRASOUND // Ecografia/Ultrassonografia
  LAB_ALTERNATIVE // Laboratório Alternativo
  RAD_ALTERNATIVE // Radiografia Alternativa
  OTHER_1 // Outros 1
  OTHER_2 // Outros 2
}

// ============================================
// PROTOCOLOS E PREFERÊNCIAS DO MÉDICO
// ============================================

model Protocol {
  id          String           @id @default(cuid())
  name        String // Nome do protocolo (ex: "Hipertensão - Inicial")
  description String? // Descrição do protocolo
  category    ProtocolCategory @default(CUSTOM)

  // Criador
  doctorId String
  doctor   User   @relation(fields: [doctorId], references: [id])

  // Configurações
  isPublic   Boolean @default(false) // Compartilhado com outros médicos
  isActive   Boolean @default(true)
  usageCount Int     @default(0) // Quantas vezes foi usado

  // Items do protocolo

  // Metadados
  tags      String[] // Tags para busca
  specialty String? // Especialidade relacionada

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([doctorId])
  @@index([category])
  @@index([name])
  @@map("protocols")
}

enum ProtocolCategory {
  HYPERTENSION // Hipertensão
  DIABETES // Diabetes
  PRENATAL // Pré-natal
  CHILDCARE // Puericultura
  MENTAL_HEALTH // Saúde Mental
  RESPIRATORY // Doenças Respiratórias
  INFECTIOUS // Doenças Infecciosas
  CHRONIC // Doenças Crônicas
  PREVENTIVE // Medicina Preventiva
  EMERGENCY // Urgência/Emergência
  CUSTOM // Personalizado
}

// ============================================
// DISPOSITIVOS DE SAÚDE CONECTADOS (IoT/Wearables)
// ============================================

// Tipo de dispositivo de saúde
// Fonte de dados do dispositivo
// Status de conexão do dispositivo
// Leitura/medição de um dispositivo
// Tipo de leitura/medição
// Contexto da medição
// Severidade de alerta
enum AlertSeverity {
  LOW // Atenção
  MEDIUM // Moderado
  HIGH // Alto
  CRITICAL // Crítico
}

// ============================================
// CONSENTIMENTO DE BIOMETRIA (LGPD)
// ============================================

// Tipos de dados biométricos que podem ser compartilhados
enum BiometricDataType {
  HEART_RATE // Frequência cardíaca
  BLOOD_PRESSURE // Pressão arterial
  OXYGEN_SATURATION // Saturação de oxigênio
  BLOOD_GLUCOSE // Glicemia
  BODY_TEMPERATURE // Temperatura
  WEIGHT // Peso
  BODY_COMPOSITION // Composição corporal (gordura, massa muscular)
  STEPS // Passos
  DISTANCE // Distância percorrida
  CALORIES // Calorias
  ACTIVITY // Atividade física
  SLEEP // Dados de sono
  HEART_SOUNDS // Sons cardíacos (estetoscópio)
  RESPIRATORY // Dados respiratórios
  ECG // Eletrocardiograma
  OTHER // Outros
}

// Consentimento individual para cada tipo de dado biométrico
model PatientBiometricConsent {
  id String @id @default(cuid())

  // Relacionamentos
  patientId String?
  patient   Patient?       @relation(fields: [patientId], references: [id], onDelete: Cascade)
  inviteId  String?

  // Tipo de dado
  dataType BiometricDataType

  // Consentimento
  isGranted Boolean   @default(false)
  grantedAt DateTime?
  revokedAt DateTime?

  // Finalidade explicada ao paciente
  purpose String // "Monitoramento de pressão arterial para acompanhamento de hipertensão"

  // Auditoria
  ipAddress String?
  userAgent String?

  // Validade (opcional - para consentimentos temporários)
  validUntil DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([patientId, dataType])
  @@index([patientId])
  @@index([inviteId])
  @@map("patient_biometric_consents")
}

enum ConsentAction {
  GRANTED
  REVOKED
  MODIFIED
}

// ==========================================
// SOLICITAÇÕES DE EXCLUSÃO DE DADOS (LGPD)
// ==========================================

model DataDeletionRequest {
  id String @id @default(cuid())

  patientId String
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Detalhes da solicitação
  reason String @db.Text
  status DeletionRequestStatus @default(PENDING)

  // Processamento
  processedAt    DateTime?
  processedBy    String?
  processorNotes String? @db.Text

  // Dados anonimizados/excluídos
  anonymizedData Json? // Registro do que foi anonimizado
  deletedData    Json? // Registro do que foi excluído

  // Auditoria
  ipAddress String?
  userAgent String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([patientId])
  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("data_deletion_requests")
}

enum DeletionRequestStatus {
  PENDING      // Aguardando análise
  IN_PROGRESS  // Em processamento
  COMPLETED    // Concluída (dados excluídos/anonimizados)
  REJECTED     // Rejeitada (com justificativa legal)
  CANCELLED    // Cancelada pelo paciente
}

// ==========================================
// LGPD - INCIDENTES DE SEGURANÇA (Art. 48)
// ==========================================

model SecurityIncident {
  id String @id @default(cuid())

  // Classificação do incidente
  title           String
  description     String   @db.Text
  severity        IncidentSeverity
  incidentType    IncidentType
  status          IncidentStatus   @default(DETECTED)

  // Dados afetados
  affectedDataTypes   String[]  // ["CPF", "email", "medical_records", etc.]
  estimatedAffected   Int?      // Número estimado de titulares afetados
  confirmedAffected   Int?      // Número confirmado após investigação

  // Timeline
  detectedAt       DateTime  @default(now())
  occurredAt       DateTime? // Quando o incidente realmente ocorreu
  containedAt      DateTime? // Quando foi contido
  resolvedAt       DateTime?

  // Notificações LGPD Art. 48
  anpdNotifiedAt          DateTime?
  anpdNotificationNumber  String?   // Número do protocolo ANPD
  titularsNotifiedAt      DateTime?
  titularsNotificationMethod String? // email, app, sms, etc.

  // Causa e remediação
  rootCause       String?   @db.Text
  actionsTaken    String?   @db.Text
  preventiveMeasures String? @db.Text

  // Responsável pela gestão
  reportedById    String?
  assignedToId    String?
  
  // Evidências e documentos
  evidences       Json?     // URLs de logs, screenshots, etc.

  // Auditoria
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Logs de atividade

  @@index([status])
  @@index([severity])
  @@index([detectedAt])
  @@index([anpdNotifiedAt])
  @@map("security_incidents")
}

enum IncidentSeverity {
  LOW       // Baixo risco
  MEDIUM    // Risco moderado
  HIGH      // Alto risco - dados sensíveis
  CRITICAL  // Crítico - vazamento confirmado de dados sensíveis
}

enum IncidentType {
  DATA_BREACH         // Vazamento de dados
  UNAUTHORIZED_ACCESS // Acesso não autorizado
  MALWARE             // Malware/ransomware
  PHISHING            // Phishing
  SYSTEM_FAILURE      // Falha de sistema
  HUMAN_ERROR         // Erro humano
  PHYSICAL_SECURITY   // Segurança física
  THIRD_PARTY         // Incidente em terceiro
  OTHER               // Outro
}

enum IncidentStatus {
  DETECTED      // Detectado
  INVESTIGATING // Em investigação
  CONTAINED     // Contido
  ERADICATED    // Erradicado
  RECOVERED     // Recuperado
  CLOSED        // Encerrado
  POST_INCIDENT // Em análise pós-incidente
}

// ==========================================
// LGPD - OPOSIÇÃO AO TRATAMENTO (Art. 18, §2º)
// ==========================================

model TreatmentOpposition {
  id String @id @default(cuid())

  patientId String
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Tipo de tratamento oposto
  treatmentType     OppositionTreatmentType
  treatmentDetails  String?   @db.Text  // Detalhes específicos

  // Motivo da oposição
  reason            String    @db.Text
  
  // Status
  status            OppositionStatus @default(PENDING)
  
  // Análise
  analysisNotes     String?   @db.Text
  legalBasis        String?   // Base legal para aceitar/rejeitar
  analyzedById      String?
  analyzedAt        DateTime?

  // Se rejeitada, justificativa legal obrigatória
  rejectionReason   String?   @db.Text

  // Efeitos aplicados
  effectsApplied    Json?     // Quais tratamentos foram suspensos

  // Auditoria
  ipAddress         String?
  userAgent         String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([patientId])
  @@index([status])
  @@index([treatmentType])
  @@map("treatment_oppositions")
}

enum OppositionTreatmentType {
  MARKETING           // Comunicações de marketing
  AI_ANALYSIS         // Análise por IA
  DATA_SHARING        // Compartilhamento com terceiros
  PROFILING           // Perfilamento/decisões automatizadas
  RESEARCH            // Uso em pesquisas
  BIOMETRIC           // Coleta de dados biométricos
  TELEMEDICINE_RECORD // Gravação de teleconsultas
  ALL                 // Todos os tratamentos não essenciais
}

enum OppositionStatus {
  PENDING    // Aguardando análise
  APPROVED   // Oposição aceita - tratamento suspenso
  REJECTED   // Oposição rejeitada (com base legal)
  PARTIAL    // Parcialmente aceita
}

// ==========================================
// QUESTIONÁRIOS INTEGRATIVOS
// ==========================================

// Tipos de sistema terapêutico
enum TherapeuticSystem {
  AYURVEDA
  HOMEOPATHY
  TCM // Traditional Chinese Medicine
  ANTHROPOSOPHY
  NATUROPATHY
  FUNCTIONAL
  GENERAL
  CUSTOM
}

// Tipos de pergunta (questionários integrativos)
enum IntakeQuestionType {
  SINGLE_CHOICE // Uma opção
  MULTIPLE_CHOICE // Múltiplas opções
  SCALE // Escala numérica (1-10, etc)
  TEXT // Texto livre
  IMAGE_CHOICE // Escolha com imagens
  YES_NO // Sim/Não
  BODY_MAP // Mapa corporal (clique em região)
}

// Status do questionário enviado
enum QuestionnaireStatus {
  PENDING // Enviado, aguardando
  IN_PROGRESS // Paciente começou
  COMPLETED // Finalizado
  EXPIRED // Expirou sem resposta
  CANCELLED // Cancelado
}

// Template de questionário (criado pelo profissional)
model QuestionnaireTemplate {
  id String @id @default(cuid())

  // Metadados
  name              String // "Avaliação de Prakriti - Ayurveda"
  description       String? // Descrição para o profissional
  patientIntro      String? // Texto de introdução para o paciente
  therapeuticSystem TherapeuticSystem @default(GENERAL)

  // Organização

  // Configurações
  estimatedMinutes   Int     @default(15)
  allowPause         Boolean @default(true) // Paciente pode pausar
  showProgress       Boolean @default(true) // Mostrar barra de progresso
  randomizeQuestions Boolean @default(false) // Aleatorizar ordem

  // Estilo visual
  themeColor String? // Cor tema (#hex)
  iconEmoji  String? // Emoji do questionário 🌿

  // Template público ou privado
  isPublic  Boolean @default(false) // Disponível para outros profissionais
  isBuiltIn Boolean @default(false) // Template do sistema

  // Criador
  createdById String?
  createdBy   User?   @relation(fields: [createdById], references: [id])

  // Questionários enviados baseados neste template
  sentQuestionnaires PatientQuestionnaire[]

  // Análise IA
  aiAnalysisPrompt String? // Prompt customizado para análise IA
  scoringLogic     Json? // Lógica de pontuação (doshas, temperamentos)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("questionnaire_templates")
}

// Pergunta individual
model IntakeQuestion {
  id String @id @default(cuid())

  categoryId String

  // Conteúdo
  text     String // "Como é sua digestão habitualmente?"
  helpText String? // Texto de ajuda/explicação
  imageUrl String? // Imagem ilustrativa

  // Tipo e configuração
  type       IntakeQuestionType @default(SINGLE_CHOICE)
  isRequired Boolean            @default(true)
  order      Int                @default(0)

  // Para escala
  scaleMin      Int? // Ex: 1
  scaleMax      Int? // Ex: 10
  scaleMinLabel String? // "Muito lenta"
  scaleMaxLabel String? // "Muito rápida"

  // Opções de resposta

  // Respostas dos pacientes

  // Mapeamento para análise (ex: dosha, temperamento)
  analysisMapping Json? // { "vata": 0, "pitta": 2, "kapha": 1 }

  // Lógica condicional (mostrar só se...)
  conditionalLogic Json? // { "showIf": { "questionId": "xxx", "value": "sim" } }

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([categoryId])
  @@map("intake_questions")
}

// Questionário enviado para um paciente específico
model PatientQuestionnaire {
  id String @id @default(cuid())

  // Template usado
  templateId String
  template   QuestionnaireTemplate @relation(fields: [templateId], references: [id])

  // Paciente
  patientId String
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Profissional que enviou
  sentById String
  sentBy   User   @relation("SentQuestionnaires", fields: [sentById], references: [id])

  // Status
  status QuestionnaireStatus @default(PENDING)

  // Token para acesso (link público)
  accessToken String @unique @default(cuid())

  // Datas
  sentAt      DateTime  @default(now())
  startedAt   DateTime? // Quando começou a responder
  completedAt DateTime? // Quando finalizou
  expiresAt   DateTime? // Data limite

  // Progresso
  lastQuestionId  String? // Última pergunta respondida (para retomar)
  progressPercent Int     @default(0)

  // Respostas

  // Análise IA
  aiAnalysis   Json? // Resultado da análise automática
  aiAnalyzedAt DateTime?

  // Notas do profissional
  professionalNotes String?

  // Associar a uma consulta (opcional)
  consultationId String?
  consultation   Consultation? @relation(fields: [consultationId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([patientId])
  @@index([templateId])
  @@index([accessToken])
  @@map("patient_questionnaires")
}

// =====================================
// EQUIPE DE CUIDADO DO PACIENTE
// =====================================
// Níveis de acesso: FULL, CONSULTATION, LIMITED, EMERGENCY, VIEW_ONLY

// Relaciona pacientes aos profissionais que podem acessá-los
model PatientCareTeam {
  id String @id @default(cuid())

  // Paciente
  patientId String
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Profissional da equipe
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Nível de acesso: FULL, CONSULTATION, LIMITED, EMERGENCY, VIEW_ONLY
  accessLevel String @default("CONSULTATION")

  // Quem adicionou à equipe
  addedById String?

  // Motivo/observação
  reason String? // Ex: "Consulta agendada", "Médico de família"

  // Controle
  isActive  Boolean @default(true)
  isPrimary Boolean @default(false)

  // Validade do acesso (null = permanente)
  validUntil DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([patientId, userId])
  @@index([patientId])
  @@index([userId])
  @@index([isActive])
  @@map("patient_care_team")
}

// ========================================
// FILA DE ESPERA (WAITING LIST)
// ========================================

model WaitingList {
  id String @id @default(cuid())

  // Paciente
  patientId String
  patient   Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)

  // Médico/Especialidade desejada
  doctorId  String? // Médico específico (opcional)
  doctor    User?   @relation(fields: [doctorId], references: [id])
  specialty String? // Especialidade genérica

  // Preferências de horário
  preferredDays  String[] // ["MON", "WED", "FRI"]
  preferredTimes String[] // ["MORNING", "AFTERNOON", "EVENING"]

  // Prioridade (1-10, quanto maior mais urgente)
  priority      Int     @default(5)
  urgencyReason String? // Motivo da urgência

  // Status
  status WaitingListStatus @default(ACTIVE)

  // Notificações enviadas
  notificationsSent Int       @default(0)
  lastNotifiedAt    DateTime?

  // Quando foi atendido
  appointmentId String?       @unique
  appointment   Consultation? @relation(fields: [appointmentId], references: [id])

  // Observações
  notes String?

  // Controle
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  expiresAt DateTime? // Data limite para atendimento

  @@index([patientId])
  @@index([doctorId])
  @@index([status])
  @@index([priority])
  @@map("waiting_lists")
}

enum WaitingListStatus {
  ACTIVE // Aguardando vaga
  NOTIFIED // Paciente foi notificado de vaga disponível
  SCHEDULED // Consulta agendada
  EXPIRED // Prazo expirou
  CANCELLED // Paciente cancelou
}

// =====================================
// TELEMEDICINE RECORDINGS
// =====================================

enum RecordingStatus {
  RECORDING
  COMPLETED
  FAILED
  CANCELLED
  DELETED
}

model TelemedicineRecording {
  id String @id @default(cuid())

  // Relacionamentos
  consultationId String
  consultation   Consultation @relation(fields: [consultationId], references: [id], onDelete: Cascade)

  doctorId String
  doctor   User   @relation("DoctorRecordings", fields: [doctorId], references: [id])

  patientId String
  patient   Patient @relation(fields: [patientId], references: [id])

  // Dados da gravação
  status    RecordingStatus @default(RECORDING)
  startedAt DateTime        @default(now())
  endedAt   DateTime?
  duration  Int? // Duração em segundos

  // Arquivo
  filePath String?
  fileName String?
  fileSize Int? // Tamanho em bytes
  fileHash String? // SHA-256 para integridade
  format   String  @default("webm")

  // LGPD - Consentimento
  patientConsent   Boolean   @default(false)
  consentTimestamp DateTime?

  // Soft delete
  deletedAt DateTime?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relações

  @@index([consultationId])
  @@index([doctorId])
  @@index([patientId])
  @@index([status])
  @@index([createdAt])
}

// =====================================
// MEDICAL CERTIFICATES (ATESTADOS)
// =====================================

enum CertificateType {
  MEDICAL_LEAVE // Atestado de afastamento (Afastamento)
  FITNESS // Atestado de aptidão física
  ACCOMPANIMENT // Atestado de acompanhante (Comparecimento)
  TIME_OFF // Atestado de comparecimento simples
  CUSTOM // Atestado personalizado

  // ============================================
  // SSF LEGACY CERTIFICATE TYPES
  // ============================================
  SHIFT_LEAVE // Atestado de Turno
  MUNICIPAL_TRANSPORT // Passe Livre Municipal
  INTERSTATE_TRANSPORT // Passe Livre Intermunicipal
  MEDICAL_EVALUATION // Perícia Médica
  MATERNITY_LEAVE // Licença Maternidade
  ADDITIONAL // Atestado Adicional
  PERIODIC_EXAM // Exame Periódico
  DISMISSAL_EXAM // Exame Demissional
  HEALTH_CERTIFICATE // Atestado de Saúde
  // ============================================
}

model MedicalCertificate {
  id String @id @default(cuid())

  // Numeração sequencial obrigatória
  sequenceNumber Int @unique
  year           Int // Ano da emissão (para reiniciar numeração)

  // Relacionamentos
  patientId String
  patient   Patient @relation(fields: [patientId], references: [id])

  doctorId String
  doctor   User   @relation("DoctorCertificates", fields: [doctorId], references: [id])

  consultationId String?
  consultation   Consultation? @relation(fields: [consultationId], references: [id])

  // Dados do atestado
  type      CertificateType @default(MEDICAL_LEAVE)
  days      Int? // Dias de afastamento (null se não aplicável)
  startDate DateTime // Data inicial do afastamento/validade
  endDate   DateTime? // Data final (calculada: startDate + days)

  // CID-10 (opcional - não obrigatório em atestados)
  includeCid     Boolean @default(false)
  cidCode        String?
  cidDescription String?

  // Texto do atestado
  title        String  @default("ATESTADO MÉDICO")
  content      String // Texto livre do atestado
  observations String? // Observações adicionais

  // PDF e assinatura
  pdfPath    String? // Caminho do PDF gerado
  pdfHash    String? // Hash SHA-256 do PDF
  qrCodeData String? // Dados do QR Code para validação

  // Assinatura digital - PKI Local (auto-assinado)
  signature        String?  // Base64 da assinatura (SHA-256 + RSA)
  signatureMethod  String   @default("NONE")  // NONE, PKI_LOCAL, ICP_BRASIL
  
  // Assinatura digital - ICP-Brasil (futuro)
  digitalSignature String? // Base64 da assinatura digital ICP-Brasil
  certificateChain String? // Cadeia de certificados
  timestamp        DateTime? // Timestamp da assinatura

  // Controle
  issuedAt      DateTime  @default(now())
  revokedAt     DateTime?
  revokedReason String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([patientId])
  @@index([doctorId])
  @@index([consultationId])
  @@index([sequenceNumber, year])
  @@index([issuedAt])
}

// =====================================
// EXTERNAL SYSTEM INTEGRATIONS
// =====================================

model IntegrationLog {
  id String @id @default(cuid())

  // Integration identifier
  integrationName String // CARTORIO, SUS, GOVERNMENT_PROTOCOL
  
  // Related certificate
  certificateId String
  
  // Submission status
  status String // SUBMITTED, PROCESSING, APPROVED, REJECTED, ERROR
  
  // Request and response data
  requestPayload  String // JSON payload sent to external system
  responseData    String // Response from external system or error details
  
  // Protocol/Reference numbers from external systems
  externalProtocolId String? // e.g., Cartório protocol, SUS record ID, etc.
  externalReference  String? // Additional reference from external system
  
  // Tracking
  submittedAt DateTime @default(now())
  lastCheckedAt DateTime?
  resolvedAt DateTime?
  
  // Error tracking
  errorCount Int @default(0)
  lastError String?
  
  // Audit
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  @@index([certificateId])
  @@index([integrationName])
  @@index([status])
  @@index([submittedAt])
}

// =====================================
// NPS (NET PROMOTER SCORE)
// =====================================

enum NpsScore {
  DETRACTOR // 0-6
  PASSIVE // 7-8
  PROMOTER // 9-10
}

model NpsResponse {
  id String @id @default(cuid())

  // Relacionamentos
  patientId String
  patient   Patient @relation(fields: [patientId], references: [id])

  consultationId String       @unique
  consultation   Consultation @relation(fields: [consultationId], references: [id])

  doctorId String
  doctor   User   @relation("DoctorNpsResponses", fields: [doctorId], references: [id])

  // Score NPS (0-10)
  score    Int // 0-10
  category NpsScore // Calculado automaticamente

  // Feedback
  feedback       String? // Comentário opcional
  wouldRecommend Boolean @default(true)

  // Categorização de feedback
  tags      String[] @default([]) // Ex: ["atendimento", "tempo_espera", "limpeza"]
  sentiment String? // POSITIVE, NEUTRAL, NEGATIVE (análise de IA)

  // Controle
  sentAt      DateTime? // Quando foi enviada a pesquisa
  respondedAt DateTime  @default(now())

  // WhatsApp integration
  sentViaWhatsApp   Boolean @default(false)
  whatsAppMessageId String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([patientId])
  @@index([doctorId])
  @@index([consultationId])
  @@index([score])
  @@index([category])
  @@index([respondedAt])
}

// Assinatura Digital (ICP-Brasil)
model DigitalCertificate {
  id     String @id @default(cuid())
  userId String
  user   User   @relation("UserDigitalCertificates", fields: [userId], references: [id], onDelete: Cascade)

  // Dados do certificado
  certificateType CertificateAuthority // A1, A3, A4
  issuer          String // Autoridade Certificadora (ex: Serasa, Certisign)
  subject         String // CN do certificado
  serialNumber    String               @unique
  notBefore       DateTime // Início da validade
  notAfter        DateTime // Fim da validade

  // Armazenamento
  certificatePem String @db.Text // Certificado em formato PEM
  publicKeyPem   String @db.Text // Chave pública
  
  // A1: Arquivo .pfx criptografado (apenas para A1)
  pfxFilePath    String? // Caminho do arquivo .pfx no servidor
  pfxPasswordHash String? // Hash da senha (para validação)

  // A3/A4: Token físico (não armazenar chave privada)
  isHardwareToken   Boolean @default(false)
  tokenSerialNumber String? // Identificador do token A3

  // Status
  isActive      Boolean   @default(true)
  revokedAt     DateTime?
  revokedReason String?

  // Uso
  lastUsedAt DateTime?
  usageCount Int       @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relações
  signedDocuments SignedDocument[]
  medicalRecordSignatures MedicalRecordSignature[]

  @@index([userId])
  @@index([notAfter])
  @@index([isActive])
}

// Documento assinado digitalmente
model SignedDocument {
  id String @id @default(cuid())

  // Tipo de documento
  documentType SignedDocumentType
  documentId   String // ID do prontuário, atestado, prescrição, etc.

  // Assinatura
  certificateId String
  certificate   DigitalCertificate @relation(fields: [certificateId], references: [id])
  signerId      String // userId do assinante
  signer        User               @relation("UserSignedDocuments", fields: [signerId], references: [id])

  // Dados da assinatura
  signatureAlgorithm String // SHA256withRSA, etc.
  signatureValue     String @db.Text // Base64 da assinatura
  signatureHash      String // Hash SHA-256 do documento original

  // Timestamp (carimbo de tempo)
  timestampAuthority String? // URL da TSA (Time Stamping Authority)
  timestampToken     String?   @db.Text // Token de tempo RFC 3161
  timestampedAt      DateTime?

  // Metadados
  ipAddress   String?
  userAgent   String?
  geolocation String? // Lat,Long (opcional)

  // Validação
  isValid          Boolean   @default(true)
  validatedAt      DateTime?
  validationResult String?   @db.Text // Resultado da última validação

  // Auditoria
  signedAt  DateTime @default(now())
  createdAt DateTime @default(now())

  // Documento gerado associado (opcional)
  generatedDocument GeneratedDocument?

  @@index([documentType, documentId])
  @@index([signerId])
  @@index([certificateId])
  @@index([signedAt])
}

enum CertificateAuthority {
  A1 // Chave privada armazenada em software (1 ano)
  A3 // Chave privada em token/smartcard (3 anos)
  A4 // Chave privada em token/smartcard (3 anos, alta segurança)
}

enum SignedDocumentType {
  MEDICAL_RECORD // Prontuário
  MEDICAL_CERTIFICATE // Atestado médico
  PRESCRIPTION // Prescrição/receita
  EXAM_REQUEST // Solicitação de exame
  EXAM_RESULT // Resultado de exame
  REFERRAL // Encaminhamento
  CONSENT_FORM // Termo de consentimento
  TELECONSULTATION // Relatório de teleconsulta
  DISCHARGE_SUMMARY // Sumário de alta
}

// Alerta de auditoria (anomalias, tentativas de acesso, etc.)
enum AuditAlertType {
  FAILED_LOGIN_ATTEMPTS // Múltiplas tentativas de login falhadas
  UNAUTHORIZED_ACCESS // Acesso a recurso sem permissão
  DATA_EXPORT_BULK // Exportação em massa de dados
  ROLE_PRIVILEGE_ESCALATION // Tentativa de elevar privilégios
  AFTER_HOURS_ACCESS // Acesso fora do horário
  UNUSUAL_ACTIVITY_PATTERN // Padrão anômalo de acesso
  SENSITIVE_DATA_ACCESS // Acesso a dados sensíveis (HIV, psiquiatria)
  GDPR_DATA_DELETION // Solicitação LGPD de exclusão
  FAILED_AUDIT_VALIDATION // Inconsistências em auditoria
  CRITICAL_ERROR // Erro crítico do sistema
  SECURITY_INCIDENT // Incidente de segurança LGPD Art. 48
}

enum AlertStatus {
  OPEN
  IN_PROGRESS
  RESOLVED
  FALSE_POSITIVE
  IGNORED
}

// ============================================================================
// WELLNESS DASHBOARD - Patient Experience Models
// ============================================================================

// Enums para Wellness Dashboard

enum BadgeRarity {
  COMMON
  RARE
  EPIC
  LEGENDARY
}

enum WellnessPlanStatus {
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

enum EventType {
  MEDICATION
  CONSULTATION
  EXAM
  VITAL
  MILESTONE
  APPOINTMENT
  DIAGNOSIS
  TREATMENT
}

// ============================================
// GEOGRAPHIC HIERARCHY MODELS (SSF Integration)
// Hierarquia: Country → State → City → Zone → District → Subprefecture → Neighborhood → Area → MicroArea
// ============================================

model Area {
  id          String  @id @default(cuid())
  code        String?
  name        String
  description String?

  microAreas MicroArea[]
  addresses  Address[]
  acsUsers   User[]       @relation("AssignedArea")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("areas")
}

// ============================================
// END GEOGRAPHIC HIERARCHY MODELS
// ============================================

// ============================================
// HEALTH UNIT / ESTABELECIMENTO DE SAÚDE
// ============================================

model HealthUnit {
  id String @id @default(cuid())

  // Identificação
  name String
  type String // "UBS", "USF", "UPA", "HOSPITAL", "CLINICA", "LABORATORIO", "FARMACIA"

  // CNES - Cadastro Nacional de Estabelecimentos de Saúde
  cnesCode String? @unique

  // Endereço
  address String?

  // Localização
  latitude  Float?
  longitude Float?

  // Contato
  phone   String?
  email   String?
  manager String? // Gestor

  // Operacional
  isActive   Boolean @default(true)
  staffCount Int     @default(0)
  beds       Int? // Para hospitais

  // ============================================
  // SSF INTEGRATION - New Relations
  // ============================================

  // Referrals
  destinationReferrals Referral[] @relation("ReferralDestinationUnit")
  // ============================================

  // Auditoria
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([cnesCode])
  @@index([isActive])
  @@map("health_units")
}

// ==========================================
// CLINIC & PROFESSIONAL SCHEDULE MANAGEMENT
// ==========================================

// Horários de funcionamento da clínica (configuração base)
model ClinicSchedule {
  id          String   @id @default(cuid())
  clinicId    String?  // Null = configuração padrão global
  dayOfWeek   Int      // 0=Domingo, 1=Segunda, ..., 6=Sábado (ISO 8601)
  openTime    String   // "08:00"
  closeTime   String   // "20:00"
  isOpen      Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([clinicId, dayOfWeek])
  @@index([clinicId])
  @@map("clinic_schedules")
}

// Horários de atendimento do profissional (dentro dos horários da clínica)
model ProfessionalSchedule {
  id              String                      @id @default(cuid())
  professionalId  String
  dayOfWeek       Int                         // 0=Domingo, 1=Segunda, ..., 6=Sábado
  startTime       String                      // "09:00"
  endTime         String                      // "17:00"
  serviceType     ScheduleServiceType         @default(BOTH) // Presencial, Remoto ou Ambos
  isActive        Boolean                     @default(true)
  
  // Aprovação (profissional solicita, admin aprova)
  status          ScheduleApprovalStatus      @default(PENDING)
  requestedBy     String                      // ID do profissional
  approvedBy      String?                     // ID do admin/secretária
  approvedAt      DateTime?
  
  createdAt       DateTime                    @default(now())
  updatedAt       DateTime                    @updatedAt

  professional    User                        @relation("ProfessionalSchedules", fields: [professionalId], references: [id], onDelete: Cascade)
  requester       User                        @relation("ScheduleRequester", fields: [requestedBy], references: [id])
  approver        User?                       @relation("ScheduleApprover", fields: [approvedBy], references: [id])

  @@index([professionalId, dayOfWeek])
  @@index([status])
  @@map("professional_schedules")
}

enum ScheduleServiceType {
  IN_PERSON  // Atendimento presencial
  REMOTE     // Atendimento remoto (teleconsulta)
  BOTH       // Ambos (presencial e remoto)
}

enum ScheduleApprovalStatus {
  PENDING    // Aguardando aprovação
  APPROVED   // Aprovado
  REJECTED   // Rejeitado
  CANCELLED  // Cancelado pelo solicitante
}

enum ScheduleRequestType {
  ADD_HOURS          // Adicionar horários de atendimento
  REMOVE_HOURS       // Remover horários
  MODIFY_HOURS       // Modificar horários existentes
  BLOCK_DATES        // Bloquear datas (plantões, férias)
  UNBLOCK_DATES      // Desbloquear datas
  CHANGE_SERVICE_TYPE // Mudar tipo de atendimento (presencial/remoto)
}

enum PatientPdfExportStatus {
  PENDING    // Aguardando processamento
  PROCESSING // Em processamento
  COMPLETED  // Concluído com sucesso
  FAILED     // Falhou
  CANCELLED  // Cancelado
}

model PatientPdfExport {
  id           String                    @id @default(cuid())
  patientId    String
  patient      Patient                   @relation("PatientPdfExports", fields: [patientId], references: [id], onDelete: Cascade)
  
  // Job tracking
  bullmqJobId  String?
  status       PatientPdfExportStatus    @default(PENDING)
  progress     Int                       @default(0)
  
  // Output
  filename     String?
  filePath     String?
  fileSize     Int?
  
  // Error tracking
  errorMessage String?
  
  // Metadata
  requestedBy  String?
  requestedAt  DateTime                  @default(now())
  completedAt  DateTime?
  expiresAt    DateTime?                 // Para limpeza automática
  
  
  @@index([patientId])
  @@index([status])
  @@index([requestedAt])
  @@map("patient_pdf_exports")
}

// ============================================================================
// INTEGRAÇÕES EXTERNAS - RNDS / e-SUS / TISS
// ============================================================================

// Submissões à RNDS (Rede Nacional de Dados em Saúde)
// Submissões ao e-SUS (AB/SISAB)
model ESUSSubmission {
  id               String   @id @default(cuid())
  
  // Tipo de ficha
  fichaType        String   // CDS_ATENDIMENTO, CDS_PROCEDIMENTO, CDS_VISITA, etc.
  
  // Referência local
  localResourceId  String
  
  // Resposta do e-SUS
  protocolo        String?  // Protocolo de recebimento
  status           String   // SENT, RECEIVED, PROCESSED, ERROR
  error            String?  @db.Text
  
  // Lote de envio
  batchId          String?
  
  // Timestamps
  submittedAt      DateTime @default(now())
  processedAt      DateTime?
  
  @@index([fichaType, status])
  @@index([localResourceId])
  @@index([batchId])
  @@map("esus_submissions")
}

// =====================================================
// MULTI-TENANCY MODELS
// =====================================================

model Tenant {
  id           String   @id @default(cuid())
  name         String
  slug         String   @unique
  domain       String?  @unique
  logoUrl      String?
  primaryColor String?
  plan         String   @default("free") // free, basic, professional, enterprise
  status       String   @default("active") // active, suspended, pending, cancelled
  settings     Json     @default("{}")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  users UserTenant[]

  @@index([status])
  @@map("tenants")
}

model UserTenant {
  id        String   @id @default(cuid())
  userId    String
  tenantId  String
  role      String   @default("member") // owner, admin, member
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([userId, tenantId])
  @@index([tenantId])
  @@map("user_tenants")
}

// =====================================================
// MEDICAL RECORD VERSIONING & SIGNATURES
// =====================================================

model MedicalRecordVersion {
  id              String   @id @default(cuid())
  medicalRecordId String
  version         Int
  title           String
  description     String?
  content         String?  @db.Text
  recordType      String
  priority        String?  @default("NORMAL")
  diagnosis       String?
  treatment       String?
  notes           String?  @db.Text
  changedBy       String
  changedAt       DateTime @default(now())
  changeType      String   @default("updated") // created, updated, restored, deleted
  changesSummary  String?

  medicalRecord MedicalRecord @relation(fields: [medicalRecordId], references: [id], onDelete: Cascade)
  changedByUser User          @relation("MedicalRecordVersions", fields: [changedBy], references: [id], onDelete: SetNull)

  @@index([medicalRecordId])
  @@index([medicalRecordId, version])
  @@index([changedAt])
  @@map("medical_record_versions")
}

model MedicalRecordSignature {
  id               String   @id @default(cuid())
  medicalRecordId  String
  signerId         String
  signatureType    String   @default("digital") // digital, icp_brasil, biometric
  certificateId    String?
  signatureData    String?  @db.Text
  signatureHash    String?
  signedAt         DateTime @default(now())
  isValid          Boolean  @default(true)
  validationErrors String?
  icpBrasilVerified Boolean? @default(false)
  certificateInfo  Json?

  medicalRecord MedicalRecord       @relation(fields: [medicalRecordId], references: [id], onDelete: Cascade)
  signer        User                @relation("MedicalRecordSignatures", fields: [signerId], references: [id], onDelete: Restrict)
  certificate   DigitalCertificate? @relation(fields: [certificateId], references: [id], onDelete: SetNull)

  @@index([medicalRecordId])
  @@index([signerId])
  @@index([signedAt])
  @@map("medical_record_signatures")
}

model MedicalRecordShare {
  id              String    @id @default(cuid())
  medicalRecordId String
  userId          String
  permission      String    @default("read") // read, write, admin
  grantedBy       String
  expiresAt       DateTime?
  createdAt       DateTime  @default(now())
  revokedAt       DateTime?

  medicalRecord MedicalRecord @relation(fields: [medicalRecordId], references: [id], onDelete: Cascade)
  user          User          @relation("SharedMedicalRecords", fields: [userId], references: [id], onDelete: Cascade)
  granter       User          @relation("GrantedMedicalRecordShares", fields: [grantedBy], references: [id], onDelete: SetNull)

  @@index([medicalRecordId])
  @@index([userId])
  @@index([expiresAt])
  @@map("medical_record_shares")
}

// =====================================================
// EXAM MODEL (for HL7/FHIR integration)
// =====================================================

model Exam {
  id              String    @id @default(cuid())
  patientId       String
  doctorId        String?
  examType        String
  examCode        String?
  description     String?
  status          String    @default("PENDING") // PENDING, SCHEDULED, IN_PROGRESS, COMPLETED, CANCELLED
  priority        String?   @default("NORMAL")
  requestedAt     DateTime  @default(now())
  scheduledAt     DateTime?
  performedAt     DateTime?
  resultAt        DateTime?
  result          String?   @db.Text
  resultValues    Json?
  referenceValues Json?
  interpretation  String?   @db.Text
  labName         String?
  labCode         String?
  fhirResourceId  String?
  hl7MessageId    String?
  notes           String?   @db.Text
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  patient Patient @relation(fields: [patientId], references: [id], onDelete: Cascade)
  doctor  User?   @relation("DoctorExams", fields: [doctorId], references: [id], onDelete: SetNull)

  @@index([patientId])
  @@index([doctorId])
  @@index([status])
  @@index([examType])
  @@index([fhirResourceId])
  @@map("exams")
}
