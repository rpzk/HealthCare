generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                     String                 @id @default(cuid())
  email                  String                 @unique
  name                   String
  role                   Role                   @default(DOCTOR)
  speciality             String?
  crmNumber              String?                @unique
  licenseNumber          String? // Generic for CRM, COREN, CRP, etc.
  licenseType            String? // 'CRM', 'COREN', 'CRP', 'OAB', etc.
  licenseState           String? // 'SP', 'RJ', etc.
  phone                  String?
  patientId              String?                @unique
  patient                Patient?               @relation("UserPatient", fields: [patientId], references: [id])
  isActive               Boolean                @default(true)
  createdAt              DateTime               @default(now())
  updatedAt              DateTime               @updatedAt
  password               String?
  aiInteractions         AIInteraction[]
  evaluationsAsEvaluator CapabilityEvaluation[] @relation("EvaluatorUser")
  evaluationsAsSubject   CapabilityEvaluation[]
  consultations          Consultation[]
  doctorSchedules        DoctorSchedule[]
  examRequests           ExamRequest[]
  medicalRecords         MedicalRecord[]
  notifications          Notification[]
  patients               Patient[]
  prescriptions          Prescription[]
  referrals              Referral[]
  scheduleExceptions     ScheduleException[]
  jobRoles               UserJobRole[]
  person                 Person?
  termAcceptances        TermAcceptance[]
  protocols              Protocol[] // Protocolos criados pelo médico
  stratumAssessments     StratumAssessment[]    @relation("UserStratumAssessments")
  strengthAssessments    StrengthAssessment[]   @relation("UserStrengthAssessments")
  developmentPlans       DevelopmentPlan[]      @relation("UserDevelopmentPlans")

  // HR Management relations
  leaveRequests         LeaveRequest[]   @relation("UserLeaveRequests")
  approvedLeaveRequests LeaveRequest[]   @relation("ApprovedLeaveRequests")
  createdSchedules      WorkSchedule[]   @relation("CreatedSchedules")
  scheduleEntries       ScheduleEntry[]  @relation("ScheduleEntries")
  timeBank              TimeBank[]
  vacationBalance       VacationBalance?
  
  // Convites de pacientes enviados
  patientInvites        PatientInvite[]
  
  // Questionários integrativos
  questionnaireTemplates QuestionnaireTemplate[]
  sentQuestionnaires     PatientQuestionnaire[] @relation("SentQuestionnaires")

  @@map("users")
}

model Person {
  id         String    @id @default(cuid())
  name       String
  socialName String?
  cpf        String?   @unique
  birthDate  DateTime?
  gender     Gender?
  motherName String?
  fatherName String?

  // Contact
  email String?
  phone String?

  // Demographics
  ethnicity      String? // IBGE
  educationLevel String?
  occupation     String?
  nationality    String?

  // System Links
  userId String? @unique
  user   User?   @relation(fields: [userId], references: [id])

  // Roles
  patient      Patient?
  professional Professional?

  // Address
  addresses PersonAddress[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("people")
}

model PersonAddress {
  id        String  @id @default(cuid())
  personId  String
  addressId String
  type      String  @default("RESIDENTIAL") // RESIDENTIAL, COMMERCIAL
  isPrimary Boolean @default(false)
  person    Person  @relation(fields: [personId], references: [id])
  address   Address @relation(fields: [addressId], references: [id])

  @@unique([personId, addressId])
  @@map("person_addresses")
}

model Professional {
  id       String @id @default(cuid())
  personId String @unique
  person   Person @relation(fields: [personId], references: [id])

  registryNumber String? // CNS/CNES
  councilNumber  String? // CRM, COREN
  councilType    String? // CRM, COREN, CRP, etc.
  councilState   String?
  cbo            String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("professionals")
}

model SystemModule {
  id          String   @id @default(cuid())
  key         String   @unique
  name        String
  description String?
  isEnabled   Boolean  @default(false)
  features    Json?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("system_modules")
}

model Patient {
  id                    String                 @id @default(cuid())
  name                  String
  email                 String                 @unique
  cpf                   String?
  birthDate             DateTime
  gender                Gender
  phone                 String?
  address               String?
  emergencyContact      String?
  allergies             String?
  createdAt             DateTime               @default(now())
  updatedAt             DateTime               @updatedAt
  currentMedications    String?
  insuranceNumber       String?
  medicalHistory        String?
  riskLevel             RiskLevel              @default(BAIXO)
  userId                String?
  latitude              Float?
  longitude             Float?
  cpfHash               String?                @unique
  householdId           String?
  isHeadOfHousehold     Boolean                @default(false)
  userAccount           User?                  @relation("UserPatient")
  addresses             Address[]
  attachments           Attachment[]
  consultations         Consultation[]
  diagnoses             Diagnosis[]
  ExamRequest           ExamRequest[]
  examResults           ExamResult[]
  financialTransactions FinancialTransaction[]
  documents             MedicalDocument[]
  medicalRecords        MedicalRecord[]
  household             Household?             @relation(fields: [householdId], references: [id])
  User                  User?                  @relation(fields: [userId], references: [id])
  personId              String?                @unique
  person                Person?                @relation(fields: [personId], references: [id])
  prescriptions         Prescription[]
  referrals             Referral[]
  vitalSigns            VitalSigns[]
  strengthAssessments   StrengthAssessment[]   @relation("PatientStrengthAssessments")
  developmentPlans      DevelopmentPlan[]      @relation("PatientDevelopmentPlans")
  
  // Dispositivos de saúde conectados
  connectedDevices      ConnectedDevice[]
  deviceReadings        DeviceReading[]
  readingThresholds     ReadingThreshold[]
  deviceSyncSessions    DeviceSyncSession[]
  
  // Consentimentos de biometria (LGPD)
  biometricConsents     PatientBiometricConsent[]
  consentAuditLogs      ConsentAuditLog[]
  patientInvite         PatientInvite?
  
  // Questionários integrativos recebidos
  questionnaires        PatientQuestionnaire[]

  @@map("patients")
}

model Household {
  id           String    @id @default(cuid())
  name         String
  address      String
  number       String?
  complement   String?
  neighborhood String?
  city         String?
  state        String?
  zipCode      String?
  microArea    String?
  familyType   String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  members      Patient[]

  @@map("households")
}

model Referral {
  id          String   @id @default(cuid())
  patientId   String
  doctorId    String
  specialty   String
  description String
  priority    String   @default("NORMAL")
  status      String   @default("PENDING")
  notes       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  doctor      User     @relation(fields: [doctorId], references: [id])
  patient     Patient  @relation(fields: [patientId], references: [id])

  @@map("referrals")
}

model MedicalRecord {
  id             String       @id @default(cuid())
  title          String
  description    String
  diagnosis      String?
  treatment      String?
  notes          String?
  recordType     RecordType
  severity       Severity     @default(LOW)
  isPrivate      Boolean      @default(false)
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  patientId      String
  doctorId       String
  sourceDocument String?
  deletedAt      DateTime?
  priority       String       @default("NORMAL")
  version        Int          @default(1)
  aiAnalysis     AIAnalysis[]
  attachments    Attachment[]
  doctor         User         @relation(fields: [doctorId], references: [id])
  patient        Patient      @relation(fields: [patientId], references: [id])

  @@index([patientId])
  @@index([doctorId])
  @@index([recordType])
  @@index([createdAt])
  @@index([deletedAt])
  @@map("medical_records")
}

model Consultation {
  id             String             @id @default(cuid())
  scheduledDate  DateTime
  actualDate     DateTime?
  duration       Int?
  type           ConsultationType
  status         ConsultationStatus @default(SCHEDULED)
  chiefComplaint String?
  history        String?
  physicalExam   String?
  assessment     String?
  plan           String?
  notes          String?
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  patientId      String
  doctorId       String
  meetingLink    String?
  videoUrl       String?

  // ============================================
  // CAMPOS DE BI - TIPO DE ATENDIMENTO (SSF)
  // ============================================
  scheduledDemand     Boolean @default(false) // Demanda Agendada
  immediateDemand     Boolean @default(false) // Demanda Imediata
  orientationOnly     Boolean @default(false) // Atendimento para Orientação
  urgencyWithObs      Boolean @default(false) // Urgência com Observação
  continuedCare       Boolean @default(false) // Atendimento Continuado
  prescriptionRenewal Boolean @default(false) // Renovação de Receita
  examEvaluation      Boolean @default(false) // Avaliação de Exame
  homeVisit           Boolean @default(false) // Visita Domiciliar

  // ============================================
  // CAMPOS DE BI - GRUPOS DE ATENDIMENTO (SSF)
  // ============================================
  mentalHealth Boolean @default(false) // Saúde Mental
  alcoholUser  Boolean @default(false) // Usuário de Álcool
  drugUser     Boolean @default(false) // Usuário de Drogas
  hypertension Boolean @default(false) // Hipertensão
  diabetes     Boolean @default(false) // Diabetes
  leprosy      Boolean @default(false) // Hanseníase
  tuberculosis Boolean @default(false) // Tuberculose
  prenatal     Boolean @default(false) // Pré-Natal
  postpartum   Boolean @default(false) // Puerpério
  stdAids      Boolean @default(false) // DST/AIDS
  preventive   Boolean @default(false) // Preventivo
  childCare    Boolean @default(false) // Puericultura

  // ============================================
  // CAMPOS DE BI - CONDUTAS (SSF)
  // ============================================
  laboratory          Boolean @default(false) // Laboratório
  radiology           Boolean @default(false) // Radiologia
  ultrasound          Boolean @default(false) // Ecografia
  obstetricUltrasound Boolean @default(false) // Ecografia Obstétrica
  mammography         Boolean @default(false) // Mamografia
  ecg                 Boolean @default(false) // ECG
  pathology           Boolean @default(false) // Patologia
  physiotherapy       Boolean @default(false) // Fisioterapia
  referralMade        Boolean @default(false) // Referência

  // ============================================
  // RELAÇÕES
  // ============================================
  doctor               User                  @relation(fields: [doctorId], references: [id])
  patient              Patient               @relation(fields: [patientId], references: [id])
  diagnoses            Diagnosis[]
  examRequests         ExamRequest[]
  financialTransaction FinancialTransaction?
  prescriptions        Prescription[]
  vitalSigns           VitalSigns[]
  
  // Questionários associados a esta consulta
  questionnaires       PatientQuestionnaire[]

  @@map("consultations")
}

model Prescription {
  id               String             @id @default(cuid())
  medication       String
  dosage           String
  frequency        String
  duration         String
  instructions     String?
  status           PrescriptionStatus @default(ACTIVE)
  startDate        DateTime           @default(now())
  endDate          DateTime?
  createdAt        DateTime           @default(now())
  updatedAt        DateTime           @updatedAt
  patientId        String
  doctorId         String
  consultationId   String?
  digitalSignature String?
  consultation     Consultation?      @relation(fields: [consultationId], references: [id])
  doctor           User               @relation(fields: [doctorId], references: [id])
  patient          Patient            @relation(fields: [patientId], references: [id])
  items            PrescriptionItem[]

  @@map("prescriptions")
}

model ExamRequest {
  id             String        @id @default(cuid())
  examType       String
  description    String?
  urgency        Urgency       @default(ROUTINE)
  status         ExamStatus    @default(REQUESTED)
  requestDate    DateTime      @default(now())
  scheduledDate  DateTime?
  completedDate  DateTime?
  results        String?
  notes          String?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  patientId      String
  doctorId       String
  consultationId String?
  attachments    Attachment[]
  consultation   Consultation? @relation(fields: [consultationId], references: [id])
  doctor         User          @relation(fields: [doctorId], references: [id])
  patient        Patient       @relation(fields: [patientId], references: [id])

  @@map("exam_requests")
}

model VitalSigns {
  id               String        @id @default(cuid())
  systolicBP       Int?
  diastolicBP      Int?
  heartRate        Int?
  respiratoryRate  Int?
  temperature      Float?
  weight           Float?
  height           Float?
  bmi              Float?
  oxygenSaturation Int?
  bloodGlucose     Int?
  notes            String?
  recordedAt       DateTime      @default(now())
  createdAt        DateTime      @default(now())
  patientId        String
  consultationId   String?
  consultation     Consultation? @relation(fields: [consultationId], references: [id])
  patient          Patient       @relation(fields: [patientId], references: [id])

  @@map("vital_signs")
}

model Attachment {
  id              String         @id @default(cuid())
  fileName        String
  originalName    String
  fileSize        Int
  mimeType        String
  filePath        String
  description     String?
  createdAt       DateTime       @default(now())
  medicalRecordId String?
  examRequestId   String?
  patientId       String?
  examRequest     ExamRequest?   @relation(fields: [examRequestId], references: [id])
  medicalRecord   MedicalRecord? @relation(fields: [medicalRecordId], references: [id])
  Patient         Patient?       @relation(fields: [patientId], references: [id])

  @@map("attachments")
}

model MedicalDocument {
  id            String                @id @default(cuid())
  fileName      String
  content       String
  fileType      DocumentFileType
  status        DocumentProcessStatus @default(PENDING)
  uploadDate    DateTime              @default(now())
  errorMessage  String?
  importResults String?
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  patientId     String?
  analysis      DocumentAnalysis?
  patient       Patient?              @relation(fields: [patientId], references: [id])

  @@map("medical_documents")
}

model DocumentAnalysis {
  id               String          @id @default(cuid())
  confidence       Float
  documentType     DocumentType
  patientInfo      String
  extractedData    String
  suggestedActions String
  analysisDate     DateTime        @default(now())
  reviewed         Boolean         @default(false)
  reviewedBy       String?
  reviewedAt       DateTime?
  documentId       String          @unique
  document         MedicalDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@map("document_analysis")
}

model ExamResult {
  id             String   @id @default(cuid())
  examType       String
  results        String
  examDate       DateTime
  sourceDocument String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  patientId      String
  patient        Patient  @relation(fields: [patientId], references: [id])

  @@map("exam_results")
}

model Address {
  id           String          @id @default(cuid())
  street       String
  number       String?
  complement   String?
  neighborhood String?
  city         String
  state        String
  zipCode      String?
  latitude     Float?
  longitude    Float?
  isPrimary    Boolean         @default(false)
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  patientId    String?
  microAreaId  String?
  microArea    MicroArea?      @relation(fields: [microAreaId], references: [id])
  patient      Patient?        @relation(fields: [patientId], references: [id])
  residents    PersonAddress[]
  Place        Place[]

  @@index([patientId])
  @@index([microAreaId])
  @@index([latitude, longitude])
  @@map("addresses")
}

model Place {
  id          String     @id @default(cuid())
  name        String
  description String?
  category    String?
  latitude    Float?
  longitude   Float?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  addressId   String?
  microAreaId String?
  address     Address?   @relation(fields: [addressId], references: [id])
  microArea   MicroArea? @relation(fields: [microAreaId], references: [id])

  @@index([microAreaId])
  @@index([latitude, longitude])
  @@map("places")
}

model MicroArea {
  id          String              @id @default(cuid())
  name        String
  code        String?             @unique
  description String?
  polygonGeo  String?
  centroidLat Float?
  centroidLng Float?
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  maxLat      Float?
  maxLng      Float?
  minLat      Float?
  minLng      Float?
  addresses   Address[]
  revisions   MicroAreaRevision[]
  places      Place[]

  @@index([centroidLat, centroidLng])
  @@index([minLat, maxLat])
  @@index([minLng, maxLng])
  @@map("micro_areas")
}

model MicroAreaRevision {
  id            String    @id @default(cuid())
  microAreaId   String
  previousGeo   String?
  newGeo        String?
  changedByUser String?
  reason        String?
  createdAt     DateTime  @default(now())
  microArea     MicroArea @relation(fields: [microAreaId], references: [id])

  @@index([microAreaId, createdAt])
  @@map("micro_area_revisions")
}

model CodeSystem {
  id          String         @id @default(cuid())
  kind        CodeSystemKind
  name        String
  version     String?
  description String?
  active      Boolean        @default(true)
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt
  codes       MedicalCode[]

  @@unique([kind, version])
  @@map("code_systems")
}

model MedicalCode {
  id                String                   @id @default(cuid())
  systemId          String
  code              String
  display           String
  description       String?
  parentId          String?
  synonyms          String?
  searchableText    String?
  active            Boolean                  @default(true)
  // Campos adicionais do sistema legado SSF
  chapter           String? // Capítulo CID-10 (I-XXII)
  isCategory        Boolean                  @default(false) // Se é categoria principal
  sexRestriction    String? // M=masculino, F=feminino, null=ambos
  crossAsterisk     String? // ETIOLOGY (+) ou MANIFESTATION (*)
  shortDescription  String? // Descrição curta/abreviada
  createdAt         DateTime                 @default(now())
  updatedAt         DateTime                 @updatedAt
  primaryIn         Diagnosis[]              @relation("PrimaryCode")
  secondaryIn       DiagnosisSecondaryCode[]
  parent            MedicalCode?             @relation("MedicalCodeHierarchy", fields: [parentId], references: [id])
  children          MedicalCode[]            @relation("MedicalCodeHierarchy")
  system            CodeSystem               @relation(fields: [systemId], references: [id])
  protocolDiagnoses ProtocolDiagnosis[]

  @@unique([systemId, code])
  @@index([code])
  @@index([display])
  @@index([chapter])
  @@index([sexRestriction])
  @@map("medical_codes")
}

model Diagnosis {
  id             String                   @id @default(cuid())
  patientId      String
  consultationId String?
  primaryCodeId  String
  status         DiagnosisStatus          @default(ACTIVE)
  certainty      DiagnosisCertainty       @default(CONFIRMED)
  notes          String?
  onsetDate      DateTime?
  resolvedDate   DateTime?
  createdAt      DateTime                 @default(now())
  updatedAt      DateTime                 @updatedAt
  consultation   Consultation?            @relation(fields: [consultationId], references: [id])
  patient        Patient                  @relation(fields: [patientId], references: [id])
  primaryCode    MedicalCode              @relation("PrimaryCode", fields: [primaryCodeId], references: [id])
  revisions      DiagnosisRevision[]
  secondaryCodes DiagnosisSecondaryCode[]

  @@index([patientId])
  @@index([consultationId])
  @@map("diagnoses")
}

model DiagnosisSecondaryCode {
  id          String      @id @default(cuid())
  diagnosisId String
  codeId      String
  order       Int         @default(0)
  createdAt   DateTime    @default(now())
  code        MedicalCode @relation(fields: [codeId], references: [id])
  diagnosis   Diagnosis   @relation(fields: [diagnosisId], references: [id], onDelete: Cascade)

  @@unique([diagnosisId, codeId])
  @@index([codeId])
  @@map("diagnosis_secondary_codes")
}

model DiagnosisRevision {
  id              String    @id @default(cuid())
  diagnosisId     String
  previous        Json?
  next            Json?
  changedAt       DateTime  @default(now())
  changedByUserId String?
  reason          String?
  diagnosis       Diagnosis @relation(fields: [diagnosisId], references: [id])

  @@index([diagnosisId, changedAt])
  @@map("diagnosis_revisions")
}

model AIInteraction {
  id         String        @id @default(cuid())
  type       AIRequestType
  prompt     String
  response   String
  confidence Float?
  metadata   Json?
  createdAt  DateTime      @default(now())
  userId     String
  user       User          @relation(fields: [userId], references: [id])

  @@map("ai_interactions")
}

model AIAnalysis {
  id              String        @id @default(cuid())
  analysisType    String
  input           String
  result          String
  confidence      Float
  suggestions     String[]
  metadata        Json?
  createdAt       DateTime      @default(now())
  medicalRecordId String
  medicalRecord   MedicalRecord @relation(fields: [medicalRecordId], references: [id])

  @@map("ai_analysis")
}

model AIQuotaUsage {
  id        String   @id @default(cuid())
  userId    String
  type      String
  date      DateTime
  count     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, type, date])
  @@index([type, date])
  @@map("ai_quota_usage")
}

model AuditLog {
  id           String   @id @default(cuid())
  userId       String
  userEmail    String
  userRole     String
  action       String
  resourceId   String?
  ipAddress    String?
  userAgent    String?
  success      Boolean  @default(true)
  errorMessage String?
  createdAt    DateTime @default(now())
  changes      Json?
  metadata     Json?
  resourceType String   @default("MEDICAL_RECORD")

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@index([resourceId, createdAt])
  @@index([resourceType, createdAt])
  @@index([success, createdAt])
  @@map("audit_logs")
}

model RateLimitLog {
  id        String    @id @default(cuid())
  userId    String
  operation String
  timestamp DateTime  @default(now())
  expiresAt DateTime?

  @@index([userId, operation, timestamp])
  @@index([expiresAt])
  @@map("rate_limit_logs")
}

model ExternalSourceUpdate {
  id            String             @id @default(cuid())
  sourceType    ExternalSourceType
  versionTag    String?
  status        String
  startedAt     DateTime           @default(now())
  finishedAt    DateTime?
  fetchedCount  Int                @default(0)
  insertedCount Int                @default(0)
  updatedCount  Int                @default(0)
  skippedCount  Int                @default(0)
  checksum      String?
  errorMessage  String?
  meta          String?
  retiredCount  Int                @default(0)

  @@index([sourceType, startedAt])
  @@map("external_source_updates")
}

model CBOGroup {
  id          String       @id @default(cuid())
  code        String       @unique
  name        String
  level       Int
  parentId    String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  parent      CBOGroup?    @relation("CBOGroupHierarchy", fields: [parentId], references: [id])
  children    CBOGroup[]   @relation("CBOGroupHierarchy")
  occupations Occupation[]

  @@index([level])
  @@map("cbo_groups")
}

model Occupation {
  id          String    @id @default(cuid())
  code        String    @unique
  title       String
  description String?
  groupId     String?
  synonyms    String?
  active      Boolean   @default(true)
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  roles       JobRole[]
  group       CBOGroup? @relation(fields: [groupId], references: [id])

  @@index([groupId])
  @@map("occupations")
}

model JobRole {
  id                 String                 @id @default(cuid())
  title              String
  occupationId       String?
  requiredMinStratum StratumLevel
  requiredMaxStratum StratumLevel?
  description        String?
  tasks              String?
  capabilitiesJson   String?
  active             Boolean                @default(true)
  createdAt          DateTime               @default(now())
  updatedAt          DateTime               @updatedAt
  evaluations        CapabilityEvaluation[]
  occupation         Occupation?            @relation(fields: [occupationId], references: [id])
  userAssignments    UserJobRole[]
  stratumProfile     JobStratumProfile?

  @@index([occupationId])
  @@map("job_roles")
}

model UserJobRole {
  id         String   @id @default(cuid())
  userId     String
  jobRoleId  String
  assignedAt DateTime @default(now())
  active     Boolean  @default(true)
  jobRole    JobRole  @relation(fields: [jobRoleId], references: [id])
  user       User     @relation(fields: [userId], references: [id])

  @@unique([userId, jobRoleId])
  @@index([jobRoleId])
  @@map("user_job_roles")
}

model CapabilityEvaluation {
  id               String        @id @default(cuid())
  subjectUserId    String
  evaluatorUserId  String
  jobRoleId        String?
  stratumAssessed  StratumLevel
  potentialStratum StratumLevel?
  timeSpanMonths   Int?
  evidence         String?
  gaps             String?
  recommendations  String?
  createdAt        DateTime      @default(now())
  capabilityScores String?
  evaluatorUser    User          @relation("EvaluatorUser", fields: [evaluatorUserId], references: [id])
  jobRole          JobRole?      @relation(fields: [jobRoleId], references: [id])
  subjectUser      User          @relation(fields: [subjectUserId], references: [id])

  @@index([subjectUserId, createdAt])
  @@index([evaluatorUserId, createdAt])
  @@index([jobRoleId])
  @@map("capability_evaluations")
}

// ========================================
// STRATUM ASSESSMENT SYSTEM (Elliott Jaques)
// ========================================

// Questionário de avaliação de Time Span
model StratumAssessment {
  id                String                      @id @default(cuid())
  userId            String
  assessmentType    AssessmentType              @default(SELF)
  status            AssessmentStatus            @default(IN_PROGRESS)
  calculatedStratum StratumLevel?
  timeSpanMonths    Int? // Horizonte temporal calculado em meses
  confidenceScore   Float? // 0-1, confiança no resultado
  startedAt         DateTime                    @default(now())
  completedAt       DateTime?
  expiresAt         DateTime? // Assessments expiram após 1 ano
  notes             String?
  user              User                        @relation("UserStratumAssessments", fields: [userId], references: [id])
  responses         StratumAssessmentResponse[]

  @@index([userId, status])
  @@index([completedAt])
  @@map("stratum_assessments")
}

// Respostas do questionário
model StratumAssessmentResponse {
  id            String            @id @default(cuid())
  assessmentId  String
  questionId    String
  answer        String // JSON com a resposta
  timeSpanValue Int? // Valor de time span desta resposta em meses
  score         Float? // Score normalizado 0-1
  answeredAt    DateTime          @default(now())
  assessment    StratumAssessment @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  question      StratumQuestion   @relation(fields: [questionId], references: [id])

  @@unique([assessmentId, questionId])
  @@index([assessmentId])
  @@map("stratum_assessment_responses")
}

// Banco de questões para avaliação
model StratumQuestion {
  id             String                      @id @default(cuid())
  category       QuestionCategory
  questionText   String
  questionType   QuestionType                @default(SCENARIO)
  options        String // JSON array de opções
  stratumMapping String // JSON mapeando opções para estratos
  weight         Float                       @default(1.0)
  order          Int                         @default(0)
  active         Boolean                     @default(true)
  createdAt      DateTime                    @default(now())
  updatedAt      DateTime                    @updatedAt
  responses      StratumAssessmentResponse[]

  @@index([category, active])
  @@map("stratum_questions")
}

// Perfil de cargo com requisitos de estrato detalhados
model JobStratumProfile {
  id                  String        @id @default(cuid())
  jobRoleId           String        @unique
  minStratum          StratumLevel
  optimalStratum      StratumLevel
  maxStratum          StratumLevel?
  timeSpanMinMonths   Int // Horizonte mínimo necessário
  timeSpanMaxMonths   Int? // Horizonte máximo (para não sub-utilizar)
  complexityFactors   String? // JSON com fatores de complexidade
  keyResponsibilities String? // JSON com responsabilidades-chave
  decisionTypes       String? // JSON com tipos de decisões
  cboCode             String? // Código CBO relacionado
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt
  jobRole             JobRole       @relation(fields: [jobRoleId], references: [id])

  @@map("job_stratum_profiles")
}

enum AssessmentType {
  SELF // Auto-avaliação
  MANAGER // Avaliação pelo gestor
  PEER // Avaliação por par
  EXTERNAL // Avaliação externa/consultor
}

enum AssessmentStatus {
  IN_PROGRESS
  COMPLETED
  EXPIRED
  CANCELLED
}

enum QuestionCategory {
  TIME_HORIZON // Horizonte temporal de planejamento
  COMPLEXITY // Complexidade de problemas
  ABSTRACTION // Nível de abstração
  UNCERTAINTY // Tolerância à ambiguidade
  DECISION_MAKING // Tomada de decisão
  LEADERSHIP // Estilo de liderança
}

enum QuestionType {
  SCENARIO // Cenário situacional
  SCALE // Escala likert
  RANKING // Ordenação de prioridades
  OPEN // Resposta aberta (para análise)
}

// ========================================
// CHARACTER STRENGTHS & GEMS SYSTEM
// ========================================

// Forças de Caráter (baseado no VIA Survey)
model CharacterStrength {
  id          String  @id @default(cuid())
  code        String  @unique // ex: "CREATIVITY", "CURIOSITY"
  name        String // Nome em português
  virtue      Virtue // Virtude associada
  description String
  examples    String? // JSON com exemplos de aplicação
  healthTips  String? // JSON com dicas de saúde relacionadas
  order       Int     @default(0)
  active      Boolean @default(true)

  assessmentResults StrengthAssessmentResult[]

  @@map("character_strengths")
}

// Assessment de Forças de Caráter
model StrengthAssessment {
  id             String                       @id @default(cuid())
  userId         String?
  patientId      String?
  assessmentType AssessmentType               @default(SELF)
  status         AssessmentStatus             @default(IN_PROGRESS)
  startedAt      DateTime                     @default(now())
  completedAt    DateTime?
  notes          String?
  user           User?                        @relation("UserStrengthAssessments", fields: [userId], references: [id])
  patient        Patient?                     @relation("PatientStrengthAssessments", fields: [patientId], references: [id])
  results        StrengthAssessmentResult[]
  responses      StrengthAssessmentResponse[]

  @@index([userId, status])
  @@index([patientId, status])
  @@map("strength_assessments")
}

// Respostas do questionário de forças
model StrengthAssessmentResponse {
  id           String             @id @default(cuid())
  assessmentId String
  questionId   String
  answer       String // JSON
  score        Float?
  answeredAt   DateTime           @default(now())
  assessment   StrengthAssessment @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  question     StrengthQuestion   @relation(fields: [questionId], references: [id])

  @@unique([assessmentId, questionId])
  @@map("strength_assessment_responses")
}

// Questões para avaliação de forças
model StrengthQuestion {
  id             String                       @id @default(cuid())
  strengthCode   String // Código da força avaliada
  questionText   String
  questionType   QuestionType                 @default(SCALE)
  options        String // JSON
  targetAudience TargetAudience               @default(BOTH)
  order          Int                          @default(0)
  active         Boolean                      @default(true)
  responses      StrengthAssessmentResponse[]

  @@index([strengthCode, active])
  @@map("strength_questions")
}

// Resultado consolidado por força
model StrengthAssessmentResult {
  id           String             @id @default(cuid())
  assessmentId String
  strengthId   String
  score        Float // 0-5
  rank         Int? // Posição no ranking (1 = mais forte)
  isTopFive    Boolean            @default(false)
  isGem        Boolean            @default(false) // Gema bruta identificada
  assessment   StrengthAssessment @relation(fields: [assessmentId], references: [id], onDelete: Cascade)
  strength     CharacterStrength  @relation(fields: [strengthId], references: [id])

  @@unique([assessmentId, strengthId])
  @@map("strength_assessment_results")
}

// Plano de Desenvolvimento Pessoal
model DevelopmentPlan {
  id               String                 @id @default(cuid())
  userId           String?
  patientId        String?
  title            String
  futureVision     String? // Visão de futuro do indivíduo
  currentStratum   StratumLevel?
  targetStratum    StratumLevel?
  primaryStrengths String? // JSON com forças principais a alavancar
  developmentAreas String? // JSON com áreas de desenvolvimento
  status           PlanStatus             @default(ACTIVE)
  startDate        DateTime               @default(now())
  targetDate       DateTime?
  completedAt      DateTime?
  createdAt        DateTime               @default(now())
  updatedAt        DateTime               @updatedAt
  user             User?                  @relation("UserDevelopmentPlans", fields: [userId], references: [id])
  patient          Patient?               @relation("PatientDevelopmentPlans", fields: [patientId], references: [id])
  goals            DevelopmentGoal[]
  milestones       DevelopmentMilestone[]

  @@index([userId, status])
  @@index([patientId, status])
  @@map("development_plans")
}

// Metas do Plano de Desenvolvimento
model DevelopmentGoal {
  id           String          @id @default(cuid())
  planId       String
  title        String
  description  String?
  category     GoalCategory
  strengthCode String? // Força de caráter relacionada
  targetDate   DateTime?
  status       GoalStatus      @default(NOT_STARTED)
  progress     Int             @default(0) // 0-100
  completedAt  DateTime?
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  plan         DevelopmentPlan @relation(fields: [planId], references: [id], onDelete: Cascade)
  actions      GoalAction[]

  @@index([planId, status])
  @@map("development_goals")
}

// Ações para alcançar metas
model GoalAction {
  id          String          @id @default(cuid())
  goalId      String
  title       String
  description String?
  frequency   ActionFrequency @default(DAILY)
  dueDate     DateTime?
  completed   Boolean         @default(false)
  completedAt DateTime?
  createdAt   DateTime        @default(now())
  goal        DevelopmentGoal @relation(fields: [goalId], references: [id], onDelete: Cascade)

  @@index([goalId, completed])
  @@map("goal_actions")
}

// Marcos de progresso
model DevelopmentMilestone {
  id          String          @id @default(cuid())
  planId      String
  title       String
  description String?
  targetDate  DateTime?
  achieved    Boolean         @default(false)
  achievedAt  DateTime?
  celebration String? // Mensagem de celebração
  createdAt   DateTime        @default(now())
  plan        DevelopmentPlan @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@index([planId, achieved])
  @@map("development_milestones")
}

enum Virtue {
  WISDOM // Sabedoria
  COURAGE // Coragem
  HUMANITY // Humanidade
  JUSTICE // Justiça
  TEMPERANCE // Temperança
  TRANSCENDENCE // Transcendência
}

enum TargetAudience {
  STAFF // Apenas colaboradores
  PATIENT // Apenas pacientes
  BOTH // Ambos
}

enum PlanStatus {
  DRAFT
  ACTIVE
  PAUSED
  COMPLETED
  CANCELLED
}

enum GoalCategory {
  HEALTH // Saúde física
  MENTAL // Saúde mental
  CAREER // Carreira/profissional
  RELATIONSHIPS // Relacionamentos
  PERSONAL // Desenvolvimento pessoal
  SPIRITUAL // Espiritual/propósito
}

enum GoalStatus {
  NOT_STARTED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ActionFrequency {
  DAILY
  WEEKLY
  BIWEEKLY
  MONTHLY
  ONCE
}

model FinancialTransaction {
  id             String            @id @default(cuid())
  type           TransactionType
  amount         Decimal           @db.Decimal(10, 2)
  description    String
  category       String
  status         TransactionStatus @default(PENDING)
  dueDate        DateTime
  paidDate       DateTime?
  paymentMethod  String?
  patientId      String?
  consultationId String?           @unique
  createdAt      DateTime          @default(now())
  updatedAt      DateTime          @updatedAt
  consultation   Consultation?     @relation(fields: [consultationId], references: [id])
  patient        Patient?          @relation(fields: [patientId], references: [id])

  @@map("financial_transactions")
}

model DoctorSchedule {
  id           String   @id @default(cuid())
  doctorId     String
  dayOfWeek    Int
  startTime    String
  endTime      String
  slotDuration Int      @default(30)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  doctor       User     @relation(fields: [doctorId], references: [id])

  @@unique([doctorId, dayOfWeek])
  @@map("doctor_schedules")
}

model ScheduleException {
  id          String   @id @default(cuid())
  doctorId    String
  date        DateTime
  isAvailable Boolean  @default(false)
  reason      String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  doctor      User     @relation(fields: [doctorId], references: [id])

  @@map("schedule_exceptions")
}

model Notification {
  id        String    @id @default(cuid())
  userId    String
  type      String
  priority  String    @default("low")
  title     String
  message   String
  read      Boolean   @default(false)
  metadata  Json?
  expiresAt DateTime?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id])

  @@index([userId, read])
  @@map("notifications")
}

model CIAP2 {
  code        String  @id
  description String
  chapter     String
  gender      String?
  active      Boolean @default(true)

  @@map("ciap2")
}

model Territory {
  id       String      @id @default(cuid())
  name     String
  type     String // 'MUNICIPALITY', 'DISTRICT', 'UNIT', 'TEAM_AREA', 'MICRO_AREA'
  parentId String?
  parent   Territory?  @relation("TerritoryHierarchy", fields: [parentId], references: [id])
  children Territory[] @relation("TerritoryHierarchy")

  // GeoJSON geometry stored as JSON
  geometry Json?

  // Center point for quick lookup
  centerLat Float?
  centerLng Float?

  // Hierarchy
  level Int? // 1=Municipality, 2=District, 3=Subprefecture, 4=Area, 5=MicroArea

  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([type])
  @@index([parentId])
  @@map("territories")
}

enum DocumentFileType {
  DOCX
  DOC
  PDF
  TXT
  RTF
}

enum DocumentProcessStatus {
  PENDING
  ANALYZING
  CLASSIFIED
  IMPORTED
  ERROR
}

enum DocumentType {
  EVOLUCAO
  EXAME
  PRESCRICAO
  ANAMNESE
  ATESTADO
  RECEITA
  LAUDO
  OUTROS
}

enum Role {
  ADMIN
  DOCTOR
  NURSE
  RECEPTIONIST
  PHYSIOTHERAPIST
  PSYCHOLOGIST
  HEALTH_AGENT
  TECHNICIAN
  PHARMACIST
  DENTIST
  NUTRITIONIST
  SOCIAL_WORKER
  OTHER
  PATIENT
}

model RegistrationInvite {
  id        String       @id @default(cuid())
  email     String
  role      Role
  token     String       @unique
  expiresAt DateTime
  status    InviteStatus @default(PENDING)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("registration_invites")
}

enum InviteStatus {
  PENDING
  USED
  EXPIRED
}

model Term {
  id       String  @id @default(cuid())
  slug     String  @unique
  title    String
  content  String  @db.Text
  version  String
  isActive Boolean @default(true)

  acceptances TermAcceptance[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("terms")
}

model TermAcceptance {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])
  termId String
  term   Term   @relation(fields: [termId], references: [id])

  acceptedAt DateTime @default(now())
  ipAddress  String?
  userAgent  String?

  @@map("term_acceptances")
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum RiskLevel {
  BAIXO
  MEDIO
  ALTO
  CRITICO
}

enum BloodType {
  A_POSITIVE
  A_NEGATIVE
  B_POSITIVE
  B_NEGATIVE
  AB_POSITIVE
  AB_NEGATIVE
  O_POSITIVE
  O_NEGATIVE
}

enum RecordType {
  CONSULTATION
  EXAM
  PRESCRIPTION
  DIAGNOSIS
  TREATMENT
  SURGERY
  EMERGENCY
  FOLLOW_UP
}

enum Severity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ConsultationType {
  INITIAL
  FOLLOW_UP
  EMERGENCY
  ROUTINE
  SPECIALIST
}

enum ConsultationStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum PrescriptionStatus {
  ACTIVE
  COMPLETED
  CANCELLED
  EXPIRED
}

enum ExamStatus {
  REQUESTED
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum Urgency {
  ROUTINE
  URGENT
  EMERGENCY
}

enum AIRequestType {
  DIAGNOSIS_SUGGESTION
  TREATMENT_RECOMMENDATION
  DRUG_INTERACTION_CHECK
  SYMPTOM_ANALYSIS
  MEDICAL_SUMMARY
  RISK_ASSESSMENT
}

enum CodeSystemKind {
  CID10
  CID11
  CIAP2
  NURSING
}

enum DiagnosisStatus {
  ACTIVE
  RESOLVED
  ENTERED_IN_ERROR
  INACTIVE
}

enum DiagnosisCertainty {
  SUSPECTED
  PROBABLE
  CONFIRMED
  RULED_OUT
}

enum ExternalSourceType {
  ICD10
  ICD11
  CIAP2
  NURSING
  CBO
}

enum StratumLevel {
  S1
  S2
  S3
  S4
  S5
  S6
  S7
  S8
}

enum TransactionType {
  INCOME
  EXPENSE
}

enum TransactionStatus {
  PENDING
  PAID
  CANCELLED
  OVERDUE
}

model SystemSetting {
  key         String   @id
  value       String
  description String?
  category    String   @default("GENERAL") // EMAIL, SECURITY, SYSTEM
  isPublic    Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@map("system_settings")
}

// ==================== HR MANAGEMENT ====================

// Tipos de ausência
enum LeaveType {
  VACATION // Férias
  SICK_LEAVE // Licença médica
  MATERNITY // Licença maternidade
  PATERNITY // Licença paternidade
  BEREAVEMENT // Luto
  PERSONAL // Particular
  TRAINING // Treinamento/Capacitação
  COMPENSATORY // Folga compensatória
  OTHER // Outro
}

// Status da solicitação de ausência
enum LeaveStatus {
  PENDING // Aguardando aprovação
  APPROVED // Aprovado
  REJECTED // Rejeitado
  CANCELLED // Cancelado
  IN_PROGRESS // Em andamento
  COMPLETED // Finalizado
}

// Solicitação de férias/folgas/licenças
model LeaveRequest {
  id     String @id @default(cuid())
  userId String
  user   User   @relation("UserLeaveRequests", fields: [userId], references: [id])

  type      LeaveType
  startDate DateTime
  endDate   DateTime
  reason    String?

  status LeaveStatus @default(PENDING)

  // Aprovação
  approvedBy    String?
  approver      User?     @relation("ApprovedLeaveRequests", fields: [approvedBy], references: [id])
  approvedAt    DateTime?
  rejectionNote String?

  // Metadados
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("leave_requests")
}

// Tipo de turno
enum ShiftType {
  MORNING // Manhã (6h-12h)
  AFTERNOON // Tarde (12h-18h)
  EVENING // Noite (18h-24h)
  NIGHT // Madrugada (0h-6h)
  FULL_DAY // Dia inteiro
  ON_CALL // Plantão/Sobreaviso
  CUSTOM // Personalizado
}

// Escala de trabalho
model WorkSchedule {
  id          String  @id @default(cuid())
  name        String // Ex: "Escala Médicos Janeiro 2025"
  description String?

  startDate DateTime // Período da escala
  endDate   DateTime

  isActive  Boolean @default(true)
  createdBy String
  creator   User    @relation("CreatedSchedules", fields: [createdBy], references: [id])

  entries ScheduleEntry[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("work_schedules")
}

// Entrada na escala (profissional + turno + data)
model ScheduleEntry {
  id         String       @id @default(cuid())
  scheduleId String
  schedule   WorkSchedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade)

  userId String
  user   User   @relation("ScheduleEntries", fields: [userId], references: [id])

  date      DateTime // Data específica
  shiftType ShiftType
  startTime String? // Horário personalizado (formato HH:mm)
  endTime   String?

  notes       String?
  isConfirmed Boolean @default(false)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([scheduleId, userId, date])
  @@map("schedule_entries")
}

// Banco de horas
model TimeBank {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id])

  date        DateTime // Data da movimentação
  minutes     Int // Positivo = crédito, Negativo = débito
  description String

  // Referência opcional a entrada de escala
  scheduleEntryId String?

  createdAt DateTime @default(now())

  @@map("time_bank")
}

// Saldo de férias
model VacationBalance {
  id     String @id @default(cuid())
  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  totalDays   Int @default(30) // Total de dias de férias por período
  usedDays    Int @default(0) // Dias já utilizados
  pendingDays Int @default(0) // Dias em solicitações pendentes

  referenceYear Int // Ano de referência (período aquisitivo)
  expiresAt     DateTime? // Data limite para uso

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("vacation_balances")
}

// ==================== INVENTORY MANAGEMENT ====================

// Unidade de medida
enum MeasureUnit {
  UNIT // Unidade
  BOX // Caixa
  PACK // Pacote
  BOTTLE // Frasco
  AMPULE // Ampola
  TUBE // Tubo
  BAG // Bolsa
  KIT // Kit
  LITER // Litro
  ML // Mililitro
  GRAM // Grama
  KG // Quilograma
  METER // Metro
  CM // Centímetro
  ROLL // Rolo
  PAIR // Par
}

// Categoria de produto
model ProductCategory {
  id          String            @id @default(cuid())
  name        String            @unique
  description String?
  parentId    String?
  parent      ProductCategory?  @relation("CategoryHierarchy", fields: [parentId], references: [id])
  children    ProductCategory[] @relation("CategoryHierarchy")
  products    Product[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("product_categories")
}

// Produto/Material
model Product {
  id          String  @id @default(cuid())
  code        String  @unique // Código interno
  barcode     String? @unique // Código de barras
  name        String
  description String?

  categoryId String?
  category   ProductCategory? @relation(fields: [categoryId], references: [id])

  unit         MeasureUnit @default(UNIT)
  minStock     Int         @default(0) // Estoque mínimo
  maxStock     Int? // Estoque máximo
  reorderPoint Int? // Ponto de reposição

  isActive     Boolean @default(true)
  isControlled Boolean @default(false) // Medicamento controlado
  requiresLot  Boolean @default(false) // Requer controle de lote

  // Pricing
  costPrice Float? // Preço de custo
  sellPrice Float? // Preço de venda (se aplicável)

  // Inventory relation
  inventory Inventory[]
  movements InventoryMovement[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("products")
}

// Tipo de movimentação
enum MovementType {
  ENTRY // Entrada
  EXIT // Saída
  ADJUSTMENT_IN // Ajuste entrada
  ADJUSTMENT_OUT // Ajuste saída
  TRANSFER_IN // Transferência entrada
  TRANSFER_OUT // Transferência saída
  LOSS // Perda/Avaria
  RETURN // Devolução
  CONSUMPTION // Consumo (uso em atendimento)
}

// Localização/Almoxarifado
model StorageLocation {
  id          String  @id @default(cuid())
  name        String  @unique
  description String?
  isActive    Boolean @default(true)

  inventory     Inventory[]
  movementsFrom InventoryMovement[] @relation("MovementFrom")
  movementsTo   InventoryMovement[] @relation("MovementTo")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("storage_locations")
}

// Estoque (quantidade por localização)
model Inventory {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id])

  locationId String
  location   StorageLocation @relation(fields: [locationId], references: [id])

  quantity    Int @default(0)
  reservedQty Int @default(0) // Quantidade reservada

  // Lote (se aplicável)
  lotNumber      String?
  expirationDate DateTime?

  lastCountDate DateTime? // Última contagem física
  lastCountQty  Int?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([productId, locationId, lotNumber])
  @@map("inventory")
}

// Movimentação de estoque
model InventoryMovement {
  id        String  @id @default(cuid())
  productId String
  product   Product @relation(fields: [productId], references: [id])

  type     MovementType
  quantity Int

  // Localização origem (para saídas/transferências)
  fromLocationId String?
  fromLocation   StorageLocation? @relation("MovementFrom", fields: [fromLocationId], references: [id])

  // Localização destino (para entradas/transferências)
  toLocationId String?
  toLocation   StorageLocation? @relation("MovementTo", fields: [toLocationId], references: [id])

  // Lote
  lotNumber      String?
  expirationDate DateTime?

  // Referência
  referenceType String? // 'consultation', 'purchase', 'transfer', etc.
  referenceId   String?

  // Custo
  unitCost  Float?
  totalCost Float?

  notes String?

  // Usuário que registrou
  userId String

  createdAt DateTime @default(now())

  @@map("inventory_movements")
}

// Fornecedor
model Supplier {
  id        String  @id @default(cuid())
  name      String
  tradeName String? // Nome fantasia
  document  String? @unique // CNPJ

  // Contato
  email   String?
  phone   String?
  website String?

  // Endereço
  address String?
  city    String?
  state   String?
  zipCode String?

  // Dados bancários
  bankInfo String?

  notes    String?
  isActive Boolean @default(true)

  purchaseOrders PurchaseOrder[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("suppliers")
}

// Status de pedido de compra
enum PurchaseOrderStatus {
  DRAFT // Rascunho
  PENDING // Aguardando aprovação
  APPROVED // Aprovado
  ORDERED // Pedido feito
  PARTIAL // Recebido parcialmente
  RECEIVED // Recebido
  CANCELLED // Cancelado
}

// Pedido de compra
model PurchaseOrder {
  id          String @id @default(cuid())
  orderNumber String @unique

  supplierId String
  supplier   Supplier @relation(fields: [supplierId], references: [id])

  status PurchaseOrderStatus @default(DRAFT)

  // Datas
  orderDate    DateTime?
  expectedDate DateTime?
  receivedDate DateTime?

  // Valores
  subtotal Float @default(0)
  discount Float @default(0)
  shipping Float @default(0)
  total    Float @default(0)

  notes String?

  // Usuários
  createdBy  String
  approvedBy String?

  items PurchaseOrderItem[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("purchase_orders")
}

// Item do pedido de compra
model PurchaseOrderItem {
  id      String        @id @default(cuid())
  orderId String
  order   PurchaseOrder @relation(fields: [orderId], references: [id], onDelete: Cascade)

  productId String

  quantity    Int
  receivedQty Int   @default(0)
  unitPrice   Float
  totalPrice  Float

  lotNumber      String?
  expirationDate DateTime?

  createdAt DateTime @default(now())

  @@map("purchase_order_items")
}

// =====================================================
// SISTEMA DE MEDICAMENTOS (Importado do SSF)
// =====================================================

model Medication {
  id        String  @id @default(cuid())
  name      String // Nome do medicamento
  synonym   String? // Sinônimo / nome alternativo
  tradeName String? // Nome comercial / fantasia

  // Classificação da receita
  prescriptionType PrescriptionType @default(SYMPTOMATIC)

  // Disponibilidade nas farmácias
  basicPharmacy      Boolean @default(false) // Farmácia da Unidade
  municipalPharmacy  Boolean @default(false) // Farmácia Municipal
  statePharmacy      Boolean @default(false) // Farmácia Estadual
  homePharmacy       Boolean @default(false) // Internação Domiciliar
  popularPharmacy    Boolean @default(false) // Farmácia Popular
  hospitalPharmacy   Boolean @default(false) // Farmácia Hospitalar
  commercialPharmacy Boolean @default(false) // Farmácia Comercial
  compoundPharmacy   Boolean @default(false) // Farmácia de Manipulação

  // Código SUS
  susCode String?

  // Informações de uso
  instructions String? // Orientação de uso padrão
  notes        String? // Notas
  description  String? // Descrição
  warnings     String? // Advertências
  interactions String? // Interações medicamentosas
  observations String? // Observações

  // Restrições
  minAge         Int? // Idade mínima
  maxAge         Int? // Idade máxima
  sexRestriction String? // M=masculino, F=feminino, null=ambos
  validityDays   Int? // Validade em dias

  // Informações da apresentação
  route       String? // Via de administração (Oral, IM, etc)
  strength    String? // Concentração (ex: 500mg)
  unit        String? // Unidade (mg, mL, etc)
  form        String? // Forma farmacêutica (comprimido, solução, etc)
  packaging   String? // Recipiente (cp, fr, amp, tb, etc)
  packageSize Int? // Capacidade do recipiente

  // Dosagem padrão
  dosePerKg         Float? // Dose por kg
  maxDailyDosePerKg Float? // Dose máxima diária por kg
  defaultFrequency  Float? // Frequência padrão
  defaultDuration   Int? // Duração padrão do tratamento
  maxQuantity       Float? // Quantidade máxima

  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  prescriptionItems     PrescriptionItem[]
  protocolPrescriptions ProtocolPrescription[]

  @@index([name])
  @@index([susCode])
  @@map("medications")
}

enum PrescriptionType {
  SYMPTOMATIC // Sintomático
  CONTINUOUS // Contínuo
  CONTROLLED // Controlado
  BLUE_B // Tipo B - Azul
  YELLOW_A // Tipo A - Amarelo
  PHYTOTHERAPIC // Fitoterápico
}

model PrescriptionItem {
  id             String  @id @default(cuid())
  prescriptionId String
  medicationId   String?

  // Se não usar medicação do catálogo
  customName String?

  dosage       String
  frequency    String
  duration     String
  quantity     Int?
  instructions String?

  prescription Prescription @relation(fields: [prescriptionId], references: [id], onDelete: Cascade)
  medication   Medication?  @relation(fields: [medicationId], references: [id])

  createdAt DateTime @default(now())

  @@map("prescription_items")
}

// =====================================================
// SISTEMA DE PROCEDIMENTOS SIGTAP (Importado do SSF)
// =====================================================

model Procedure {
  id             String  @id @default(cuid())
  code           String  @unique // Código SIGTAP (10 dígitos)
  name           String
  complexity     Int? // Complexidade (0-3)
  financing      String? // Financiamento (N=Nacional, I=Municipal, F=Federal)
  minAge         Int? // Idade mínima (em meses)
  maxAge         Int? // Idade máxima (em meses)
  sexRestriction String? // M=masculino, F=feminino, null=ambos

  // Agrupamentos
  group    String? // Grupo do procedimento
  subgroup String? // Subgrupo

  // CBO relacionado
  cboRequired String? // CBO necessário para realizar

  active    Boolean   @default(true)
  validFrom DateTime? // Data de vigência
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  @@index([code])
  @@index([name])
  @@map("procedures")
}

// =====================================================
// CATÁLOGO DE EXAMES (Importado do SSF)
// =====================================================

model ExamCatalog {
  id           String  @id @default(cuid())
  name         String
  abbreviation String? // Abreviação (ex: HMG, GLI)
  description  String?

  // Tipo de exame
  examCategory ExamCategory

  // Restrições
  minAge         Int?
  maxAge         Int?
  sexRestriction String? // M=masculino, F=feminino, null=ambos

  // Código SUS relacionado
  susCode String?

  // Preparação
  preparation String? // Instruções de preparo

  active    Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  protocolExams ProtocolExam[]

  @@index([name])
  @@index([examCategory])
  @@map("exam_catalog")
}

enum ExamCategory {
  LABORATORY // Laboratório
  RADIOLOGY // Radiografia
  ECG // Eletrocardiograma
  PHYSIOTHERAPY // Fisioterapia
  APAC // APAC
  CYTOPATHOLOGY // Citopatológico
  MAMMOGRAPHY // Mamografia
  ULTRASOUND // Ecografia/Ultrassonografia
  LAB_ALTERNATIVE // Laboratório Alternativo
  RAD_ALTERNATIVE // Radiografia Alternativa
  OTHER_1 // Outros 1
  OTHER_2 // Outros 2
}

// ============================================
// PROTOCOLOS E PREFERÊNCIAS DO MÉDICO
// ============================================

model Protocol {
  id          String           @id @default(cuid())
  name        String // Nome do protocolo (ex: "Hipertensão - Inicial")
  description String? // Descrição do protocolo
  category    ProtocolCategory @default(CUSTOM)

  // Criador
  doctorId String
  doctor   User   @relation(fields: [doctorId], references: [id])

  // Configurações
  isPublic   Boolean @default(false) // Compartilhado com outros médicos
  isActive   Boolean @default(true)
  usageCount Int     @default(0) // Quantas vezes foi usado

  // Items do protocolo
  prescriptions ProtocolPrescription[]
  exams         ProtocolExam[]
  referrals     ProtocolReferral[]
  diagnoses     ProtocolDiagnosis[]

  // Metadados
  tags      String[] // Tags para busca
  specialty String? // Especialidade relacionada

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([doctorId])
  @@index([category])
  @@index([name])
  @@map("protocols")
}

model ProtocolPrescription {
  id         String   @id @default(cuid())
  protocolId String
  protocol   Protocol @relation(fields: [protocolId], references: [id], onDelete: Cascade)

  // Medicação do catálogo (opcional)
  medicationId String?
  medication   Medication? @relation(fields: [medicationId], references: [id])

  // Dados da prescrição
  medicationName String // Nome (pode ser diferente do catálogo)
  dosage         String // Dosagem
  frequency      String // Frequência
  duration       String // Duração
  instructions   String? // Orientações
  quantity       Float? // Quantidade
  route          String? // Via de administração

  // Ordem no protocolo
  sortOrder Int @default(0)

  @@index([protocolId])
  @@map("protocol_prescriptions")
}

model ProtocolExam {
  id         String   @id @default(cuid())
  protocolId String
  protocol   Protocol @relation(fields: [protocolId], references: [id], onDelete: Cascade)

  // Exame do catálogo (opcional)
  examCatalogId String?
  examCatalog   ExamCatalog? @relation(fields: [examCatalogId], references: [id])

  // Dados do exame
  examName    String // Nome do exame
  description String? // Indicação/descrição
  priority    Urgency @default(ROUTINE)
  notes       String? // Observações

  // Ordem no protocolo
  sortOrder Int @default(0)

  @@index([protocolId])
  @@map("protocol_exams")
}

model ProtocolReferral {
  id         String   @id @default(cuid())
  protocolId String
  protocol   Protocol @relation(fields: [protocolId], references: [id], onDelete: Cascade)

  // Dados do encaminhamento
  specialty   String // Especialidade
  description String // Motivo/indicação
  priority    Urgency @default(ROUTINE)
  notes       String? // Observações

  // Ordem no protocolo
  sortOrder Int @default(0)

  @@index([protocolId])
  @@map("protocol_referrals")
}

model ProtocolDiagnosis {
  id         String   @id @default(cuid())
  protocolId String
  protocol   Protocol @relation(fields: [protocolId], references: [id], onDelete: Cascade)

  // CID do catálogo
  medicalCodeId String?
  medicalCode   MedicalCode? @relation(fields: [medicalCodeId], references: [id])

  // Dados do diagnóstico
  cidCode     String // Código CID
  description String // Descrição
  isPrimary   Boolean @default(false) // Diagnóstico principal

  // Ordem no protocolo
  sortOrder Int @default(0)

  @@index([protocolId])
  @@map("protocol_diagnoses")
}

enum ProtocolCategory {
  HYPERTENSION // Hipertensão
  DIABETES // Diabetes
  PRENATAL // Pré-natal
  CHILDCARE // Puericultura
  MENTAL_HEALTH // Saúde Mental
  RESPIRATORY // Doenças Respiratórias
  INFECTIOUS // Doenças Infecciosas
  CHRONIC // Doenças Crônicas
  PREVENTIVE // Medicina Preventiva
  EMERGENCY // Urgência/Emergência
  CUSTOM // Personalizado
}

// ============================================
// DISPOSITIVOS DE SAÚDE CONECTADOS (IoT/Wearables)
// ============================================

// Tipo de dispositivo de saúde
enum HealthDeviceType {
  BLOOD_PRESSURE   // Medidor de pressão
  GLUCOMETER       // Glicosímetro
  PULSE_OXIMETER   // Oxímetro de pulso
  THERMOMETER      // Termômetro
  SCALE            // Balança
  HEART_RATE       // Monitor cardíaco
  ECG              // Eletrocardiograma
  STETHOSCOPE      // Estetoscópio digital
  OTOSCOPE         // Otoscópio digital
  DERMATOSCOPE     // Dermatoscópio
  SPIROMETER       // Espirômetro
  SLEEP_TRACKER    // Monitor de sono
  ACTIVITY_TRACKER // Monitor de atividade
  CGM              // Monitor contínuo de glicose
  SMARTWATCH       // Relógio inteligente
  FITNESS_BAND     // Pulseira fitness
  OTHER            // Outro
}

// Fonte de dados do dispositivo
enum DeviceDataSource {
  APPLE_HEALTHKIT    // Apple HealthKit (iOS)
  GOOGLE_FIT         // Google Fit (Android)
  HEALTH_CONNECT     // Health Connect (Android 14+)
  DIRECT_BLUETOOTH   // Conexão Bluetooth direta
  DIRECT_WIFI        // Conexão WiFi direta
  MANUAL_ENTRY       // Entrada manual
  API_INTEGRATION    // Integração via API do fabricante
  FHIR               // Padrão FHIR
  OPEN_MHEALTH       // Padrão Open mHealth
}

// Status de conexão do dispositivo
enum DeviceConnectionStatus {
  CONNECTED       // Conectado e sincronizando
  DISCONNECTED    // Desconectado
  PAIRING         // Em processo de pareamento
  ERROR           // Erro de conexão
  NEEDS_AUTH      // Precisa reautorização
}

// Dispositivo de saúde conectado
model ConnectedDevice {
  id                String                 @id @default(cuid())
  patientId         String
  patient           Patient                @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  // Identificação do dispositivo
  deviceType        HealthDeviceType
  deviceName        String                 // Nome do dispositivo (ex: "Apple Watch Series 9")
  manufacturer      String?                // Fabricante (ex: "Apple", "Omron")
  model             String?                // Modelo específico
  serialNumber      String?                // Número de série
  firmwareVersion   String?                // Versão do firmware
  
  // Conexão
  dataSource        DeviceDataSource
  connectionStatus  DeviceConnectionStatus @default(DISCONNECTED)
  lastSyncAt        DateTime?              // Última sincronização
  syncFrequency     Int?                   // Frequência de sync em minutos
  
  // Autenticação (para APIs de fabricantes)
  accessToken       String?                // Token de acesso (criptografado)
  refreshToken      String?                // Token de refresh (criptografado)
  tokenExpiresAt    DateTime?              // Expiração do token
  
  // Configurações
  isActive          Boolean                @default(true)
  autoSync          Boolean                @default(true)
  notifyOnAbnormal  Boolean                @default(true) // Alertar valores anormais
  
  // Metadados
  metadata          Json?                  // Dados extras específicos do dispositivo
  createdAt         DateTime               @default(now())
  updatedAt         DateTime               @updatedAt
  
  // Relações
  readings          DeviceReading[]
  
  @@unique([patientId, serialNumber])
  @@index([patientId])
  @@index([deviceType])
  @@map("connected_devices")
}

// Leitura/medição de um dispositivo
model DeviceReading {
  id              String          @id @default(cuid())
  deviceId        String?
  device          ConnectedDevice? @relation(fields: [deviceId], references: [id], onDelete: Cascade)
  patientId       String
  patient         Patient         @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  // Tipo de medição
  readingType     ReadingType
  
  // Valores (usando campos genéricos para flexibilidade)
  primaryValue    Float           // Valor principal (ex: glicose, SpO2, peso)
  secondaryValue  Float?          // Valor secundário (ex: pressão diastólica)
  tertiaryValue   Float?          // Valor terciário (se necessário)
  unit            String          // Unidade (ex: "mg/dL", "mmHg", "kg")
  
  // Contexto da medição
  measuredAt      DateTime        // Quando a medição foi feita
  syncedAt        DateTime        @default(now()) // Quando foi sincronizado
  
  // Metadados da medição
  context         ReadingContext? // Contexto (jejum, pós-refeição, etc)
  notes           String?         // Observações
  isManual        Boolean         @default(false) // Entrada manual vs automática
  
  // Qualidade/confiabilidade
  confidence      Float?          // Score de confiança (0-1)
  isValid         Boolean         @default(true)
  invalidReason   String?         // Motivo se inválido
  
  // Alertas
  isAbnormal      Boolean         @default(false)
  alertSeverity   AlertSeverity?  // Severidade se anormal
  alertTriggered  Boolean         @default(false)
  
  // Dados brutos do dispositivo
  rawData         Json?           // Dados originais do dispositivo
  
  createdAt       DateTime        @default(now())
  
  @@index([patientId, readingType])
  @@index([deviceId, measuredAt])
  @@index([measuredAt])
  @@index([isAbnormal])
  @@map("device_readings")
}

// Tipo de leitura/medição
enum ReadingType {
  // Cardiovascular
  BLOOD_PRESSURE_SYSTOLIC   // Pressão sistólica
  BLOOD_PRESSURE_DIASTOLIC  // Pressão diastólica
  BLOOD_PRESSURE            // Pressão (combinado)
  HEART_RATE                // Frequência cardíaca
  HEART_RATE_VARIABILITY    // Variabilidade cardíaca
  ECG_RHYTHM                // Ritmo ECG
  
  // Respiratório
  OXYGEN_SATURATION         // SpO2
  RESPIRATORY_RATE          // Frequência respiratória
  PEAK_FLOW                 // Pico de fluxo
  FEV1                      // Volume expiratório forçado
  
  // Metabólico
  BLOOD_GLUCOSE             // Glicemia
  BLOOD_GLUCOSE_FASTING     // Glicemia em jejum
  BLOOD_GLUCOSE_POSTMEAL    // Glicemia pós-prandial
  KETONES                   // Cetonas
  
  // Composição corporal
  WEIGHT                    // Peso
  BMI                       // IMC
  BODY_FAT                  // % gordura corporal
  MUSCLE_MASS               // Massa muscular
  BONE_MASS                 // Massa óssea
  WATER_PERCENTAGE          // % água corporal
  VISCERAL_FAT              // Gordura visceral
  
  // Temperatura
  BODY_TEMPERATURE          // Temperatura corporal
  SKIN_TEMPERATURE          // Temperatura da pele
  
  // Sono
  SLEEP_DURATION            // Duração do sono
  SLEEP_DEEP                // Sono profundo
  SLEEP_REM                 // Sono REM
  SLEEP_LIGHT               // Sono leve
  SLEEP_AWAKE               // Tempo acordado
  SLEEP_SCORE               // Score de qualidade
  
  // Atividade física
  STEPS                     // Passos
  DISTANCE                  // Distância
  CALORIES_BURNED           // Calorias queimadas
  ACTIVE_MINUTES            // Minutos ativos
  FLOORS_CLIMBED            // Andares subidos
  EXERCISE_DURATION         // Duração exercício
  
  // Estresse/Mental
  STRESS_LEVEL              // Nível de estresse
  MINDFULNESS_MINUTES       // Minutos de mindfulness
  
  // Áudio/Exame
  HEART_SOUND               // Som cardíaco (estetoscópio)
  LUNG_SOUND                // Som pulmonar
  EAR_IMAGE                 // Imagem do ouvido (otoscópio)
  SKIN_IMAGE                // Imagem da pele (dermatoscópio)
  
  // Outros
  HYDRATION                 // Hidratação
  MENSTRUAL_CYCLE           // Ciclo menstrual
  MEDICATION_TAKEN          // Medicação tomada
  OTHER                     // Outro
}

// Contexto da medição
enum ReadingContext {
  FASTING           // Em jejum
  BEFORE_MEAL       // Antes da refeição
  AFTER_MEAL        // Depois da refeição
  BEFORE_EXERCISE   // Antes do exercício
  AFTER_EXERCISE    // Depois do exercício
  RESTING           // Em repouso
  ACTIVE            // Em atividade
  SLEEPING          // Dormindo
  WAKING            // Ao acordar
  BEDTIME           // Ao deitar
  STRESSED          // Estressado
  RELAXED           // Relaxado
  ILL               // Doente
  MEDICATED         // Após medicação
}

// Severidade de alerta
enum AlertSeverity {
  LOW       // Atenção
  MEDIUM    // Moderado
  HIGH      // Alto
  CRITICAL  // Crítico
}

// Limites de referência para alertas
model ReadingThreshold {
  id              String      @id @default(cuid())
  patientId       String?     // Se null, é padrão global
  patient         Patient?    @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  readingType     ReadingType
  
  // Limites
  criticalLow     Float?      // Abaixo = crítico
  warningLow      Float?      // Abaixo = atenção
  normalMin       Float?      // Início da faixa normal
  normalMax       Float?      // Fim da faixa normal
  warningHigh     Float?      // Acima = atenção
  criticalHigh    Float?      // Acima = crítico
  
  // Aplicabilidade
  context         ReadingContext? // Contexto específico (ex: jejum para glicose)
  ageMin          Int?        // Idade mínima
  ageMax          Int?        // Idade máxima
  
  isActive        Boolean     @default(true)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt
  
  @@unique([patientId, readingType, context])
  @@index([readingType])
  @@map("reading_thresholds")
}

// Sessão de sincronização
model DeviceSyncSession {
  id              String          @id @default(cuid())
  patientId       String
  patient         Patient         @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  dataSource      DeviceDataSource
  startedAt       DateTime        @default(now())
  completedAt     DateTime?
  
  // Estatísticas
  readingsImported Int            @default(0)
  readingsSkipped  Int            @default(0)
  errors          Int             @default(0)
  
  status          SyncStatus      @default(IN_PROGRESS)
  errorMessage    String?
  
  @@index([patientId])
  @@map("device_sync_sessions")
}

enum SyncStatus {
  IN_PROGRESS
  COMPLETED
  FAILED
  PARTIAL
}

// ============================================
// CONSENTIMENTO DE BIOMETRIA (LGPD)
// ============================================

// Tipos de dados biométricos que podem ser compartilhados
enum BiometricDataType {
  HEART_RATE           // Frequência cardíaca
  BLOOD_PRESSURE       // Pressão arterial
  OXYGEN_SATURATION    // Saturação de oxigênio
  BLOOD_GLUCOSE        // Glicemia
  BODY_TEMPERATURE     // Temperatura
  WEIGHT               // Peso
  BODY_COMPOSITION     // Composição corporal (gordura, massa muscular)
  STEPS                // Passos
  DISTANCE             // Distância percorrida
  CALORIES             // Calorias
  ACTIVITY             // Atividade física
  SLEEP                // Dados de sono
  HEART_SOUNDS         // Sons cardíacos (estetoscópio)
  RESPIRATORY          // Dados respiratórios
  ECG                  // Eletrocardiograma
  OTHER                // Outros
}

// Convite para paciente com opções de consentimento
model PatientInvite {
  id              String        @id @default(cuid())
  
  // Dados do convite
  email           String
  phone           String?       // Para envio via WhatsApp
  patientName     String        // Nome do paciente
  token           String        @unique
  expiresAt       DateTime
  status          InviteStatus  @default(PENDING)
  
  // Quem enviou
  invitedById     String
  invitedBy       User          @relation(fields: [invitedById], references: [id])
  
  // Dados pré-preenchidos (opcional)
  birthDate       DateTime?
  cpf             String?
  
  // Mensagem personalizada
  customMessage   String?
  
  // Consentimento aceito
  consentAcceptedAt DateTime?
  consentIpAddress  String?     // IP do aceite (auditoria)
  consentUserAgent  String?     // Navegador usado (auditoria)
  
  // Relação com consentimentos
  biometricConsents PatientBiometricConsent[]
  
  // Paciente criado (após aceite)
  patientId       String?       @unique
  patient         Patient?      @relation(fields: [patientId], references: [id])
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  
  @@index([email])
  @@index([token])
  @@map("patient_invites")
}

// Consentimento individual para cada tipo de dado biométrico
model PatientBiometricConsent {
  id              String            @id @default(cuid())
  
  // Relacionamentos
  patientId       String?
  patient         Patient?          @relation(fields: [patientId], references: [id], onDelete: Cascade)
  inviteId        String?
  invite          PatientInvite?    @relation(fields: [inviteId], references: [id], onDelete: Cascade)
  
  // Tipo de dado
  dataType        BiometricDataType
  
  // Consentimento
  isGranted       Boolean           @default(false)
  grantedAt       DateTime?
  revokedAt       DateTime?
  
  // Finalidade explicada ao paciente
  purpose         String            // "Monitoramento de pressão arterial para acompanhamento de hipertensão"
  
  // Auditoria
  ipAddress       String?
  userAgent       String?
  
  // Validade (opcional - para consentimentos temporários)
  validUntil      DateTime?
  
  createdAt       DateTime          @default(now())
  updatedAt       DateTime          @updatedAt
  
  @@unique([patientId, dataType])
  @@index([patientId])
  @@index([inviteId])
  @@map("patient_biometric_consents")
}

// Histórico de alterações de consentimento (auditoria LGPD)
model ConsentAuditLog {
  id              String            @id @default(cuid())
  
  patientId       String
  patient         Patient           @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  dataType        BiometricDataType
  action          ConsentAction     // GRANTED, REVOKED, MODIFIED
  previousValue   Boolean?
  newValue        Boolean
  
  // Auditoria
  ipAddress       String?
  userAgent       String?
  reason          String?           // Motivo da alteração (opcional)
  
  createdAt       DateTime          @default(now())
  
  @@index([patientId])
  @@map("consent_audit_logs")
}

enum ConsentAction {
  GRANTED
  REVOKED
  MODIFIED
}

// ==========================================
// QUESTIONÁRIOS INTEGRATIVOS
// ==========================================

// Tipos de sistema terapêutico
enum TherapeuticSystem {
  AYURVEDA
  HOMEOPATHY
  TCM              // Traditional Chinese Medicine
  ANTHROPOSOPHY
  NATUROPATHY
  FUNCTIONAL
  GENERAL
  CUSTOM
}

// Tipos de pergunta (questionários integrativos)
enum IntakeQuestionType {
  SINGLE_CHOICE     // Uma opção
  MULTIPLE_CHOICE   // Múltiplas opções
  SCALE             // Escala numérica (1-10, etc)
  TEXT              // Texto livre
  IMAGE_CHOICE      // Escolha com imagens
  YES_NO            // Sim/Não
  BODY_MAP          // Mapa corporal (clique em região)
}

// Status do questionário enviado
enum QuestionnaireStatus {
  PENDING           // Enviado, aguardando
  IN_PROGRESS       // Paciente começou
  COMPLETED         // Finalizado
  EXPIRED           // Expirou sem resposta
  CANCELLED         // Cancelado
}

// Template de questionário (criado pelo profissional)
model QuestionnaireTemplate {
  id                String              @id @default(cuid())
  
  // Metadados
  name              String              // "Avaliação de Prakriti - Ayurveda"
  description       String?             // Descrição para o profissional
  patientIntro      String?             // Texto de introdução para o paciente
  therapeuticSystem TherapeuticSystem   @default(GENERAL)
  
  // Organização
  categories        IntakeCategory[]
  
  // Configurações
  estimatedMinutes  Int                 @default(15)
  allowPause        Boolean             @default(true)  // Paciente pode pausar
  showProgress      Boolean             @default(true)  // Mostrar barra de progresso
  randomizeQuestions Boolean            @default(false) // Aleatorizar ordem
  
  // Estilo visual
  themeColor        String?             // Cor tema (#hex)
  iconEmoji         String?             // Emoji do questionário 🌿
  
  // Template público ou privado
  isPublic          Boolean             @default(false) // Disponível para outros profissionais
  isBuiltIn         Boolean             @default(false) // Template do sistema
  
  // Criador
  createdById       String?
  createdBy         User?               @relation(fields: [createdById], references: [id])
  
  // Questionários enviados baseados neste template
  sentQuestionnaires PatientQuestionnaire[]
  
  // Análise IA
  aiAnalysisPrompt  String?             // Prompt customizado para análise IA
  scoringLogic      Json?               // Lógica de pontuação (doshas, temperamentos)
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  @@map("questionnaire_templates")
}

// Categoria/Seção dentro do questionário
model IntakeCategory {
  id                String              @id @default(cuid())
  
  templateId        String
  template          QuestionnaireTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)
  
  name              String              // "Características Físicas"
  description       String?             // Breve explicação
  order             Int                 @default(0)
  iconEmoji         String?             // 🏃 para seção física
  
  questions         IntakeQuestion[]
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  @@index([templateId])
  @@map("intake_categories")
}

// Pergunta individual
model IntakeQuestion {
  id                String              @id @default(cuid())
  
  categoryId        String
  category          IntakeCategory      @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  
  // Conteúdo
  text              String              // "Como é sua digestão habitualmente?"
  helpText          String?             // Texto de ajuda/explicação
  imageUrl          String?             // Imagem ilustrativa
  
  // Tipo e configuração
  type              IntakeQuestionType  @default(SINGLE_CHOICE)
  isRequired        Boolean             @default(true)
  order             Int                 @default(0)
  
  // Para escala
  scaleMin          Int?                // Ex: 1
  scaleMax          Int?                // Ex: 10
  scaleMinLabel     String?             // "Muito lenta"
  scaleMaxLabel     String?             // "Muito rápida"
  
  // Opções de resposta
  options           IntakeQuestionOption[]
  
  // Respostas dos pacientes
  answers           PatientAnswer[]
  
  // Mapeamento para análise (ex: dosha, temperamento)
  analysisMapping   Json?               // { "vata": 0, "pitta": 2, "kapha": 1 }
  
  // Lógica condicional (mostrar só se...)
  conditionalLogic  Json?               // { "showIf": { "questionId": "xxx", "value": "sim" } }
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  @@index([categoryId])
  @@map("intake_questions")
}

// Opção de resposta (para choice questions)
model IntakeQuestionOption {
  id                String              @id @default(cuid())
  
  questionId        String
  question          IntakeQuestion      @relation(fields: [questionId], references: [id], onDelete: Cascade)
  
  text              String              // "Rápida e irregular"
  description       String?             // Explicação adicional
  imageUrl          String?             // Imagem/ícone
  emoji             String?             // 🔥
  order             Int                 @default(0)
  
  // Pontuação para análise
  scoreValue        Json?               // { "vata": 2, "pitta": 0, "kapha": 0 }
  
  // Respostas que selecionaram esta opção
  selectedIn        PatientAnswer[]
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  @@index([questionId])
  @@map("intake_question_options")
}

// Questionário enviado para um paciente específico
model PatientQuestionnaire {
  id                String              @id @default(cuid())
  
  // Template usado
  templateId        String
  template          QuestionnaireTemplate @relation(fields: [templateId], references: [id])
  
  // Paciente
  patientId         String
  patient           Patient             @relation(fields: [patientId], references: [id], onDelete: Cascade)
  
  // Profissional que enviou
  sentById          String
  sentBy            User                @relation("SentQuestionnaires", fields: [sentById], references: [id])
  
  // Status
  status            QuestionnaireStatus @default(PENDING)
  
  // Token para acesso (link público)
  accessToken       String              @unique @default(cuid())
  
  // Datas
  sentAt            DateTime            @default(now())
  startedAt         DateTime?           // Quando começou a responder
  completedAt       DateTime?           // Quando finalizou
  expiresAt         DateTime?           // Data limite
  
  // Progresso
  lastQuestionId    String?             // Última pergunta respondida (para retomar)
  progressPercent   Int                 @default(0)
  
  // Respostas
  answers           PatientAnswer[]
  
  // Análise IA
  aiAnalysis        Json?               // Resultado da análise automática
  aiAnalyzedAt      DateTime?
  
  // Notas do profissional
  professionalNotes String?
  
  // Associar a uma consulta (opcional)
  consultationId    String?
  consultation      Consultation?       @relation(fields: [consultationId], references: [id])
  
  createdAt         DateTime            @default(now())
  updatedAt         DateTime            @updatedAt
  
  @@index([patientId])
  @@index([templateId])
  @@index([accessToken])
  @@map("patient_questionnaires")
}

// Resposta individual do paciente
model PatientAnswer {
  id                String              @id @default(cuid())
  
  questionnaireId   String
  questionnaire     PatientQuestionnaire @relation(fields: [questionnaireId], references: [id], onDelete: Cascade)
  
  questionId        String
  question          IntakeQuestion      @relation(fields: [questionId], references: [id])
  
  // Resposta (dependendo do tipo)
  textValue         String?             // Para TEXT
  numericValue      Float?              // Para SCALE
  booleanValue      Boolean?            // Para YES_NO
  
  // Para SINGLE/MULTIPLE_CHOICE
  selectedOptionId  String?
  selectedOption    IntakeQuestionOption? @relation(fields: [selectedOptionId], references: [id])
  
  // Para MULTIPLE_CHOICE (múltiplas seleções)
  selectedOptionIds String[]            // Array de IDs
  
  // Para BODY_MAP
  bodyMapData       Json?               // { "region": "head", "x": 50, "y": 30, "note": "dor" }
  
  // Metadados
  answeredAt        DateTime            @default(now())
  timeSpentSeconds  Int?                // Tempo gasto na pergunta
  
  @@unique([questionnaireId, questionId])
  @@index([questionnaireId])
  @@map("patient_answers")
}
