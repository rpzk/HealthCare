// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id         String   @id @default(cuid())
  email      String   @unique
  password   String? // Campo de senha com hash bcrypt (opcional para compatibilidade)
  name       String
  role       Role     @default(DOCTOR)
  speciality String?
  crmNumber  String?  @unique
  phone      String?
  isActive   Boolean  @default(true)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relacionamentos
  patients       Patient[]
  consultations  Consultation[]
  prescriptions  Prescription[]
  examRequests   ExamRequest[]
  medicalRecords MedicalRecord[]
  aiInteractions AIInteraction[]

  @@map("users")
}

model Patient {
  id                 String    @id @default(cuid())
  name               String
  email              String    @unique
  phone              String?
  cpf                String?   // armazenada criptografada
  cpfHash            String?   @unique // hash para busca/indexa√ß√£o sem expor valor
  birthDate          DateTime
  gender             Gender
  emergencyContact   String?
  address            String?
  medicalHistory     String?   @db.Text
  allergies          String?   @db.Text
  currentMedications String?   @db.Text
  riskLevel          RiskLevel @default(BAIXO)
  insuranceNumber    String?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relacionamentos
  consultations  Consultation[]
  prescriptions  Prescription[]
  vitalSigns     VitalSigns[]
  attachments    Attachment[]
  documents      MedicalDocument[]
  examResults    ExamResult[]
  medicalRecords MedicalRecord[]
  addresses      Address[]
  User           User?             @relation(fields: [userId], references: [id])
  userId         String?
  ExamRequest    ExamRequest[]

  @@map("patients")
}

model MedicalRecord {
  id             String     @id @default(cuid())
  title          String
  description    String
  diagnosis      String?
  treatment      String?
  notes          String?
  recordType     RecordType
  severity       Severity   @default(LOW)
  isPrivate      Boolean    @default(false)
  sourceDocument String? // Para vincular a documentos importados
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt

  // Relacionamentos
  patient     Patient      @relation(fields: [patientId], references: [id])
  patientId   String
  doctor      User         @relation(fields: [doctorId], references: [id])
  doctorId    String
  attachments Attachment[]
  aiAnalysis  AIAnalysis[]

  @@map("medical_records")
}

model Consultation {
  id             String             @id @default(cuid())
  scheduledDate  DateTime
  actualDate     DateTime?
  duration       Int? // em minutos
  type           ConsultationType
  status         ConsultationStatus @default(SCHEDULED)
  chiefComplaint String?
  history        String?
  physicalExam   String?
  assessment     String?
  plan           String?
  notes          String?
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt

  // Relacionamentos
  patient       Patient        @relation(fields: [patientId], references: [id])
  patientId     String
  doctor        User           @relation(fields: [doctorId], references: [id])
  doctorId      String
  prescriptions Prescription[]
  examRequests  ExamRequest[]
  vitalSigns    VitalSigns[]

  @@map("consultations")
}

model Prescription {
  id           String             @id @default(cuid())
  medication   String
  dosage       String
  frequency    String
  duration     String
  instructions String?
  status       PrescriptionStatus @default(ACTIVE)
  startDate    DateTime           @default(now())
  endDate      DateTime?
  createdAt    DateTime           @default(now())
  updatedAt    DateTime           @updatedAt

  // Relacionamentos
  patient        Patient       @relation(fields: [patientId], references: [id])
  patientId      String
  doctor         User          @relation(fields: [doctorId], references: [id])
  doctorId       String
  consultation   Consultation? @relation(fields: [consultationId], references: [id])
  consultationId String?

  @@map("prescriptions")
}

model ExamRequest {
  id            String     @id @default(cuid())
  examType      String
  description   String?
  urgency       Urgency    @default(ROUTINE)
  status        ExamStatus @default(REQUESTED)
  requestDate   DateTime   @default(now())
  scheduledDate DateTime?
  completedDate DateTime?
  results       String?
  notes         String?
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  // Relacionamentos
  patient        Patient       @relation(fields: [patientId], references: [id])
  patientId      String
  doctor         User          @relation(fields: [doctorId], references: [id])
  doctorId       String
  consultation   Consultation? @relation(fields: [consultationId], references: [id])
  consultationId String?
  attachments    Attachment[]

  @@map("exam_requests")
}

model VitalSigns {
  id               String   @id @default(cuid())
  systolicBP       Int? // Press√£o arterial sist√≥lica
  diastolicBP      Int? // Press√£o arterial diast√≥lica
  heartRate        Int? // Frequ√™ncia card√≠aca
  respiratoryRate  Int? // Frequ√™ncia respirat√≥ria
  temperature      Float? // Temperatura corporal
  weight           Float? // Peso em kg
  height           Float? // Altura em cm
  bmi              Float? // IMC calculado
  oxygenSaturation Int? // Satura√ß√£o de oxig√™nio
  bloodGlucose     Int? // Glicemia
  notes            String?
  recordedAt       DateTime @default(now())
  createdAt        DateTime @default(now())

  // Relacionamentos
  patient        Patient       @relation(fields: [patientId], references: [id])
  patientId      String
  consultation   Consultation? @relation(fields: [consultationId], references: [id])
  consultationId String?

  @@map("vital_signs")
}

model Attachment {
  id           String   @id @default(cuid())
  fileName     String
  originalName String
  fileSize     Int
  mimeType     String
  filePath     String
  description  String?
  createdAt    DateTime @default(now())

  // Relacionamentos
  medicalRecord   MedicalRecord? @relation(fields: [medicalRecordId], references: [id])
  medicalRecordId String?
  examRequest     ExamRequest?   @relation(fields: [examRequestId], references: [id])
  examRequestId   String?
  Patient         Patient?       @relation(fields: [patientId], references: [id])
  patientId       String?

  @@map("attachments")
}

// üìÑ Modelos para Importa√ß√£o Inteligente de Documentos M√©dicos

model MedicalDocument {
  id            String                @id @default(cuid())
  fileName      String
  content       String                @db.Text
  fileType      DocumentFileType
  status        DocumentProcessStatus @default(PENDING)
  uploadDate    DateTime              @default(now())
  errorMessage  String?
  importResults String?               @db.Text
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt

  // Relacionamentos
  patient   Patient?          @relation(fields: [patientId], references: [id])
  patientId String?
  analysis  DocumentAnalysis?

  @@map("medical_documents")
}

model DocumentAnalysis {
  id               String       @id @default(cuid())
  confidence       Float
  documentType     DocumentType
  patientInfo      String       @db.Text // JSON
  extractedData    String       @db.Text // JSON
  suggestedActions String       @db.Text // JSON
  analysisDate     DateTime     @default(now())
  reviewed         Boolean      @default(false)
  reviewedBy       String?
  reviewedAt       DateTime?

  // Relacionamentos
  document   MedicalDocument @relation(fields: [documentId], references: [id], onDelete: Cascade)
  documentId String          @unique

  @@map("document_analysis")
}

model ExamResult {
  id             String   @id @default(cuid())
  examType       String
  results        String   @db.Text // JSON para m√∫ltiplos resultados
  examDate       DateTime
  sourceDocument String?
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relacionamentos
  patient   Patient @relation(fields: [patientId], references: [id])
  patientId String

  @@map("exam_results")
}

// Endere√ßos estruturados com georreferenciamento
model Address {
  id           String     @id @default(cuid())
  street       String
  number       String?
  complement   String?
  neighborhood String?
  city         String
  state        String
  zipCode      String?
  latitude     Float?
  longitude    Float?
  isPrimary    Boolean    @default(false)
  createdAt    DateTime   @default(now())
  updatedAt    DateTime   @updatedAt

  // Relacionamentos
  patient     Patient?   @relation(fields: [patientId], references: [id])
  patientId   String?
  microArea   MicroArea? @relation(fields: [microAreaId], references: [id])
  microAreaId String?
  Place       Place[]

  @@index([patientId])
  @@map("addresses")
}

// Locais de interesse (unidades, eventos, etc.) com georreferenciamento
model Place {
  id          String     @id @default(cuid())
  name        String
  description String?
  category    String?
  latitude    Float?
  longitude   Float?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // Relacionamentos
  address   Address?   @relation(fields: [addressId], references: [id])
  addressId String?
  microArea MicroArea? @relation(fields: [microAreaId], references: [id])
  microAreaId String?

  @@map("places")
}

// Micro√°reas/√°reas adstritas para planejamento epidemiol√≥gico
model MicroArea {
  id           String   @id @default(cuid())
  name         String
  code         String?  @unique
  description  String?
  polygonGeo   String?  @db.Text // GeoJSON da √°rea (opcional)
  centroidLat  Float?
  centroidLng  Float?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relacionamentos
  addresses Address[]
  places    Place[]

  @@map("micro_areas")
}

enum DocumentFileType {
  DOCX
  DOC
  PDF
  TXT
  RTF
}

enum DocumentProcessStatus {
  PENDING
  ANALYZING
  CLASSIFIED
  IMPORTED
  ERROR
}

enum DocumentType {
  EVOLUCAO
  EXAME
  PRESCRICAO
  ANAMNESE
  ATESTADO
  RECEITA
  LAUDO
  OUTROS
}

model AIInteraction {
  id         String        @id @default(cuid())
  type       AIRequestType
  prompt     String
  response   String
  confidence Float?
  metadata   Json?
  createdAt  DateTime      @default(now())

  // Relacionamentos
  user   User   @relation(fields: [userId], references: [id])
  userId String

  @@map("ai_interactions")
}

model AIAnalysis {
  id           String   @id @default(cuid())
  analysisType String
  input        String
  result       String
  confidence   Float
  suggestions  String[]
  metadata     Json?
  createdAt    DateTime @default(now())

  // Relacionamentos
  medicalRecord   MedicalRecord @relation(fields: [medicalRecordId], references: [id])
  medicalRecordId String

  @@map("ai_analysis")
}

// Uso agregado di√°rio de quotas de IA para evitar COUNT caro em tempo real
model AIQuotaUsage {
  id        String   @id @default(cuid())
  userId    String
  type      String
  date      DateTime
  count     Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, type, date])
  @@index([type, date])
  @@map("ai_quota_usage")
}

// Logs de auditoria persistentes
model AuditLog {
  id          String   @id @default(cuid())
  userId      String
  userEmail   String
  userRole    String
  action      String
  resource    String
  resourceId  String?
  details     String?   @db.Text
  ipAddress   String?
  userAgent   String?
  success     Boolean   @default(true)
  errorMessage String?
  createdAt   DateTime  @default(now())

  @@index([userId, createdAt])
  @@index([action, createdAt])
  @@map("audit_logs")
}

// Enums
enum Role {
  ADMIN
  DOCTOR
  NURSE
  RECEPTIONIST
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum RiskLevel {
  BAIXO
  MEDIO
  ALTO
  CRITICO
}

enum BloodType {
  A_POSITIVE
  A_NEGATIVE
  B_POSITIVE
  B_NEGATIVE
  AB_POSITIVE
  AB_NEGATIVE
  O_POSITIVE
  O_NEGATIVE
}

enum RecordType {
  CONSULTATION
  EXAM
  PRESCRIPTION
  DIAGNOSIS
  TREATMENT
  SURGERY
  EMERGENCY
  FOLLOW_UP
}

enum Severity {
  LOW
  MEDIUM
  HIGH
  CRITICAL
}

enum ConsultationType {
  INITIAL
  FOLLOW_UP
  EMERGENCY
  ROUTINE
  SPECIALIST
}

enum ConsultationStatus {
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
  NO_SHOW
}

enum PrescriptionStatus {
  ACTIVE
  COMPLETED
  CANCELLED
  EXPIRED
}

enum ExamStatus {
  REQUESTED
  SCHEDULED
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum Urgency {
  ROUTINE
  URGENT
  EMERGENCY
}

enum AIRequestType {
  DIAGNOSIS_SUGGESTION
  TREATMENT_RECOMMENDATION
  DRUG_INTERACTION_CHECK
  SYMPTOM_ANALYSIS
  MEDICAL_SUMMARY
  RISK_ASSESSMENT
}
